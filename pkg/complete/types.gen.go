// Package pkg provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package pkg

import (
	"encoding/json"
	"fmt"
)

const (
	SlackAuthScopes = "slackAuth.Scopes"
)

// Defines values for ConversationsListChannelIsChannel.
const (
	ConversationsListChannelIsChannelTrue ConversationsListChannelIsChannel = true
)

// Defines values for ConversationsListConversationType.
const (
	ConversationsListConversationTypeIm ConversationsListConversationType = "im"

	ConversationsListConversationTypeNpim ConversationsListConversationType = "npim"

	ConversationsListConversationTypePrivateChannel ConversationsListConversationType = "private_channel"

	ConversationsListConversationTypePublicChannel ConversationsListConversationType = "public_channel"
)

// Defines values for ConversationsListGroupIsGroup.
const (
	ConversationsListGroupIsGroupTrue ConversationsListGroupIsGroup = true
)

// Defines values for ConversationsListImIsIm.
const (
	ConversationsListImIsImTrue ConversationsListImIsIm = true
)

// Defines values for DefsOkTrue.
const (
	DefsOkTrueTrue DefsOkTrue = true
)

// This is a very loose definition, in the future, we'll populate this with deeper schema in this definition namespace.
type Blocks []struct {
	Type string `json:"type"`
}

// ConversationsListChannel defines model for conversations.list_Channel.
type ConversationsListChannel struct {
	Created            float32                           `json:"created"`
	Creator            string                            `json:"creator"`
	Id                 string                            `json:"id"`
	IsArchived         bool                              `json:"is_archived"`
	IsChannel          ConversationsListChannelIsChannel `json:"is_channel"`
	IsExtShared        bool                              `json:"is_ext_shared"`
	IsGeneral          bool                              `json:"is_general"`
	IsGroup            bool                              `json:"is_group"`
	IsIm               bool                              `json:"is_im"`
	IsMember           bool                              `json:"is_member"`
	IsMpim             bool                              `json:"is_mpim"`
	IsOrgShared        bool                              `json:"is_org_shared"`
	IsPendingExtShared bool                              `json:"is_pending_ext_shared"`
	IsPrivate          bool                              `json:"is_private"`
	IsShared           bool                              `json:"is_shared"`
	Name               string                            `json:"name"`
	NameNormalized     string                            `json:"name_normalized"`
	NumMembers         float32                           `json:"num_members"`
	PendingShared      []map[string]interface{}          `json:"pending_shared"`
	PreviousNames      []string                          `json:"previous_names"`
	Purpose            struct {
		Creator string  `json:"creator"`
		LastSet float32 `json:"last_set"`
		Value   string  `json:"value"`
	} `json:"purpose"`
	Topic struct {
		Creator string  `json:"creator"`
		LastSet float32 `json:"last_set"`
		Value   string  `json:"value"`
	} `json:"topic"`
	Unlinked float32 `json:"unlinked"`
}

// ConversationsListChannelIsChannel defines model for ConversationsListChannel.IsChannel.
type ConversationsListChannelIsChannel bool

// ConversationsListConversationType defines model for conversations.list_ConversationType.
type ConversationsListConversationType string

// Schema for error response from conversations.list method
type ConversationsListErrorResponseBody struct {
	Error                string                 `json:"error"`
	Ok                   bool                   `json:"ok"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ConversationsListGroup defines model for conversations.list_Group.
type ConversationsListGroup struct {
	Created            float32                       `json:"created"`
	Creator            string                        `json:"creator"`
	Id                 string                        `json:"id"`
	IsArchived         bool                          `json:"is_archived"`
	IsChannel          bool                          `json:"is_channel"`
	IsExtShared        bool                          `json:"is_ext_shared"`
	IsGeneral          bool                          `json:"is_general"`
	IsGroup            ConversationsListGroupIsGroup `json:"is_group"`
	IsIm               bool                          `json:"is_im"`
	IsMember           bool                          `json:"is_member"`
	IsMpim             bool                          `json:"is_mpim"`
	IsOpen             bool                          `json:"is_open"`
	IsOrgShared        bool                          `json:"is_org_shared"`
	IsPendingExtShared bool                          `json:"is_pending_ext_shared"`
	IsPrivate          bool                          `json:"is_private"`
	IsShared           bool                          `json:"is_shared"`
	Name               string                        `json:"name"`
	NameNormalized     string                        `json:"name_normalized"`
	PendingShared      []map[string]interface{}      `json:"pending_shared"`
	Priority           float32                       `json:"priority"`
	Purpose            struct {
		Creator string  `json:"creator"`
		LastSet float32 `json:"last_set"`
		Value   string  `json:"value"`
	} `json:"purpose"`
	Topic struct {
		Creator string  `json:"creator"`
		LastSet float32 `json:"last_set"`
		Value   string  `json:"value"`
	} `json:"topic"`
	Unlinked float32 `json:"unlinked"`
}

// ConversationsListGroupIsGroup defines model for ConversationsListGroup.IsGroup.
type ConversationsListGroupIsGroup bool

// ConversationsListIm defines model for conversations.list_Im.
type ConversationsListIm struct {
	Created       float32                 `json:"created"`
	Id            string                  `json:"id"`
	IsIm          ConversationsListImIsIm `json:"is_im"`
	IsOrgShared   bool                    `json:"is_org_shared"`
	IsUserDeleted bool                    `json:"is_user_deleted"`
	Priority      float32                 `json:"priority"`
	User          string                  `json:"user"`
}

// ConversationsListImIsIm defines model for ConversationsListIm.IsIm.
type ConversationsListImIsIm bool

// Schema for successful response from conversations.list method
type ConversationsListResponseBody struct {
	Channels         []interface{} `json:"channels"`
	Ok               bool          `json:"ok"`
	ResponseMetadata struct {
		NextCursor string `json:"next_cursor"`
	} `json:"response_metadata"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// DefsAppId defines model for defs_app_id.
type DefsAppId string

// DefsBotId defines model for defs_bot_id.
type DefsBotId string

// DefsChannel defines model for defs_channel.
type DefsChannel string

// DefsChannelId defines model for defs_channel_id.
type DefsChannelId string

// DefsCommentId defines model for defs_comment_id.
type DefsCommentId string

// DefsDmId defines model for defs_dm_id.
type DefsDmId string

// DefsFileId defines model for defs_file_id.
type DefsFileId string

// DefsGroupId defines model for defs_group_id.
type DefsGroupId string

// DefsOkTrue defines model for defs_ok_true.
type DefsOkTrue bool

// DefsPinnedInfo defines model for defs_pinned_info.
type DefsPinnedInfo map[string]interface{}

// DefsTeam defines model for defs_team.
type DefsTeam string

// DefsTs defines model for defs_ts.
type DefsTs string

// DefsUserId defines model for defs_user_id.
type DefsUserId string

// DefsWorkspaceId defines model for defs_workspace_id.
type DefsWorkspaceId string

// ObjsBotProfile defines model for objs_bot_profile.
type ObjsBotProfile struct {
	AppId   DefsAppId `json:"app_id"`
	Deleted bool      `json:"deleted"`
	Icons   struct {
		Image36 string `json:"image_36"`
		Image48 string `json:"image_48"`
		Image72 string `json:"image_72"`
	} `json:"icons"`
	Id      DefsBotId `json:"id"`
	Name    string    `json:"name"`
	TeamId  DefsTeam  `json:"team_id"`
	Updated int       `json:"updated"`
}

// ObjsComment defines model for objs_comment.
type ObjsComment struct {
	Comment    string          `json:"comment"`
	Created    int             `json:"created"`
	Id         DefsCommentId   `json:"id"`
	IsIntro    bool            `json:"is_intro"`
	IsStarred  *bool           `json:"is_starred,omitempty"`
	NumStars   *int            `json:"num_stars,omitempty"`
	PinnedInfo *DefsPinnedInfo `json:"pinned_info,omitempty"`
	PinnedTo   *[]DefsChannel  `json:"pinned_to,omitempty"`
	Reactions  *[]ObjsReaction `json:"reactions,omitempty"`
	Timestamp  int             `json:"timestamp"`
	User       DefsUserId      `json:"user"`
}

// ObjsFile defines model for objs_file.
type ObjsFile struct {
	Channels          *[]DefsChannelId `json:"channels,omitempty"`
	CommentsCount     *int             `json:"comments_count,omitempty"`
	Created           *int             `json:"created,omitempty"`
	DateDelete        *int             `json:"date_delete,omitempty"`
	DisplayAsBot      *bool            `json:"display_as_bot,omitempty"`
	Editable          *bool            `json:"editable,omitempty"`
	Editor            *DefsUserId      `json:"editor,omitempty"`
	ExternalId        *string          `json:"external_id,omitempty"`
	ExternalType      *string          `json:"external_type,omitempty"`
	ExternalUrl       *string          `json:"external_url,omitempty"`
	Filetype          *string          `json:"filetype,omitempty"`
	Groups            *[]DefsGroupId   `json:"groups,omitempty"`
	HasRichPreview    *bool            `json:"has_rich_preview,omitempty"`
	Id                *DefsFileId      `json:"id,omitempty"`
	ImageExifRotation *int             `json:"image_exif_rotation,omitempty"`
	Ims               *[]DefsDmId      `json:"ims,omitempty"`
	IsExternal        *bool            `json:"is_external,omitempty"`
	IsPublic          *bool            `json:"is_public,omitempty"`
	IsStarred         *bool            `json:"is_starred,omitempty"`
	IsTombstoned      *bool            `json:"is_tombstoned,omitempty"`
	LastEditor        *DefsUserId      `json:"last_editor,omitempty"`
	Mimetype          *string          `json:"mimetype,omitempty"`
	Mode              *string          `json:"mode,omitempty"`
	Name              *string          `json:"name,omitempty"`
	NonOwnerEditable  *bool            `json:"non_owner_editable,omitempty"`
	NumStars          *int             `json:"num_stars,omitempty"`
	OriginalH         *int             `json:"original_h,omitempty"`
	OriginalW         *int             `json:"original_w,omitempty"`
	Permalink         *string          `json:"permalink,omitempty"`
	PermalinkPublic   *string          `json:"permalink_public,omitempty"`
	PinnedInfo        *DefsPinnedInfo  `json:"pinned_info,omitempty"`
	PinnedTo          *[]DefsChannel   `json:"pinned_to,omitempty"`
	PrettyType        *string          `json:"pretty_type,omitempty"`
	Preview           *string          `json:"preview,omitempty"`
	PublicUrlShared   *bool            `json:"public_url_shared,omitempty"`
	Reactions         *[]ObjsReaction  `json:"reactions,omitempty"`
	Shares            *struct {
		Private *map[string]interface{} `json:"private,omitempty"`
		Public  *map[string]interface{} `json:"public,omitempty"`
	} `json:"shares,omitempty"`
	Size               *int      `json:"size,omitempty"`
	SourceTeam         *DefsTeam `json:"source_team,omitempty"`
	State              *string   `json:"state,omitempty"`
	Thumb1024          *string   `json:"thumb_1024,omitempty"`
	Thumb1024H         *int      `json:"thumb_1024_h,omitempty"`
	Thumb1024W         *int      `json:"thumb_1024_w,omitempty"`
	Thumb160           *string   `json:"thumb_160,omitempty"`
	Thumb360           *string   `json:"thumb_360,omitempty"`
	Thumb360H          *int      `json:"thumb_360_h,omitempty"`
	Thumb360W          *int      `json:"thumb_360_w,omitempty"`
	Thumb480           *string   `json:"thumb_480,omitempty"`
	Thumb480H          *int      `json:"thumb_480_h,omitempty"`
	Thumb480W          *int      `json:"thumb_480_w,omitempty"`
	Thumb64            *string   `json:"thumb_64,omitempty"`
	Thumb720           *string   `json:"thumb_720,omitempty"`
	Thumb720H          *int      `json:"thumb_720_h,omitempty"`
	Thumb720W          *int      `json:"thumb_720_w,omitempty"`
	Thumb80            *string   `json:"thumb_80,omitempty"`
	Thumb800           *string   `json:"thumb_800,omitempty"`
	Thumb800H          *int      `json:"thumb_800_h,omitempty"`
	Thumb800W          *int      `json:"thumb_800_w,omitempty"`
	Thumb960           *string   `json:"thumb_960,omitempty"`
	Thumb960H          *int      `json:"thumb_960_h,omitempty"`
	Thumb960W          *int      `json:"thumb_960_w,omitempty"`
	ThumbTiny          *string   `json:"thumb_tiny,omitempty"`
	Timestamp          *int      `json:"timestamp,omitempty"`
	Title              *string   `json:"title,omitempty"`
	Updated            *int      `json:"updated,omitempty"`
	UrlPrivate         *string   `json:"url_private,omitempty"`
	UrlPrivateDownload *string   `json:"url_private_download,omitempty"`
	User               *string   `json:"user,omitempty"`
	UserTeam           *DefsTeam `json:"user_team,omitempty"`
	Username           *string   `json:"username,omitempty"`
}

// ObjsMessage defines model for objs_message.
type ObjsMessage struct {
	Attachments *[]struct {
		Fallback    *string `json:"fallback,omitempty"`
		Id          int     `json:"id"`
		ImageBytes  *int    `json:"image_bytes,omitempty"`
		ImageHeight *int    `json:"image_height,omitempty"`
		ImageUrl    *string `json:"image_url,omitempty"`
		ImageWidth  *int    `json:"image_width,omitempty"`
	} `json:"attachments,omitempty"`

	// This is a very loose definition, in the future, we'll populate this with deeper schema in this definition namespace.
	Blocks       *Blocks                 `json:"blocks,omitempty"`
	BotId        *map[string]interface{} `json:"bot_id,omitempty"`
	BotProfile   *ObjsBotProfile         `json:"bot_profile,omitempty"`
	ClientMsgId  *string                 `json:"client_msg_id,omitempty"`
	Comment      *ObjsComment            `json:"comment,omitempty"`
	DisplayAsBot *bool                   `json:"display_as_bot,omitempty"`
	File         *ObjsFile               `json:"file,omitempty"`
	Files        *[]ObjsFile             `json:"files,omitempty"`
	Icons        *struct {
		Emoji   *string `json:"emoji,omitempty"`
		Image64 *string `json:"image_64,omitempty"`
	} `json:"icons,omitempty"`
	Inviter          *DefsUserId           `json:"inviter,omitempty"`
	IsDelayedMessage *bool                 `json:"is_delayed_message,omitempty"`
	IsIntro          *bool                 `json:"is_intro,omitempty"`
	IsStarred        *bool                 `json:"is_starred,omitempty"`
	LastRead         *DefsTs               `json:"last_read,omitempty"`
	LatestReply      *DefsTs               `json:"latest_reply,omitempty"`
	Name             *string               `json:"name,omitempty"`
	OldName          *string               `json:"old_name,omitempty"`
	ParentUserId     *DefsUserId           `json:"parent_user_id,omitempty"`
	Permalink        *string               `json:"permalink,omitempty"`
	PinnedTo         *[]DefsChannel        `json:"pinned_to,omitempty"`
	Purpose          *string               `json:"purpose,omitempty"`
	Reactions        *[]ObjsReaction       `json:"reactions,omitempty"`
	ReplyCount       *int                  `json:"reply_count,omitempty"`
	ReplyUsers       *[]DefsUserId         `json:"reply_users,omitempty"`
	ReplyUsersCount  *int                  `json:"reply_users_count,omitempty"`
	SourceTeam       *DefsWorkspaceId      `json:"source_team,omitempty"`
	Subscribed       *bool                 `json:"subscribed,omitempty"`
	Subtype          *string               `json:"subtype,omitempty"`
	Team             *DefsWorkspaceId      `json:"team,omitempty"`
	Text             string                `json:"text"`
	ThreadTs         *DefsTs               `json:"thread_ts,omitempty"`
	Topic            *string               `json:"topic,omitempty"`
	Ts               DefsTs                `json:"ts"`
	Type             string                `json:"type"`
	UnreadCount      *int                  `json:"unread_count,omitempty"`
	Upload           *bool                 `json:"upload,omitempty"`
	User             *DefsUserId           `json:"user,omitempty"`
	UserProfile      *ObjsUserProfileShort `json:"user_profile,omitempty"`
	UserTeam         *DefsWorkspaceId      `json:"user_team,omitempty"`
	Username         *string               `json:"username,omitempty"`
}

// ObjsReaction defines model for objs_reaction.
type ObjsReaction struct {
	Count int          `json:"count"`
	Name  string       `json:"name"`
	Users []DefsUserId `json:"users"`
}

// ObjsUserProfileShort defines model for objs_user_profile_short.
type ObjsUserProfileShort struct {
	AvatarHash            string          `json:"avatar_hash"`
	DisplayName           string          `json:"display_name"`
	DisplayNameNormalized *string         `json:"display_name_normalized,omitempty"`
	FirstName             string          `json:"first_name"`
	Image72               string          `json:"image_72"`
	IsRestricted          bool            `json:"is_restricted"`
	IsUltraRestricted     bool            `json:"is_ultra_restricted"`
	Name                  string          `json:"name"`
	RealName              string          `json:"real_name"`
	RealNameNormalized    *string         `json:"real_name_normalized,omitempty"`
	Team                  DefsWorkspaceId `json:"team"`
}

// AdminAppsApproveJSONBody defines parameters for AdminAppsApprove.
type AdminAppsApproveJSONBody struct {
	// The id of the app to approve.
	AppId *string `json:"app_id,omitempty"`

	// The id of the request to approve.
	RequestId *string `json:"request_id,omitempty"`
	TeamId    *string `json:"team_id,omitempty"`
}

// AdminAppsApproveParams defines parameters for AdminAppsApprove.
type AdminAppsApproveParams struct {
	// Authentication token. Requires scope: `admin.apps:write`
	Token string `json:"token"`
}

// AdminAppsApprovedListParams defines parameters for AdminAppsApprovedList.
type AdminAppsApprovedListParams struct {
	// Authentication token. Requires scope: `admin.apps:read`
	Token string `json:"token"`

	// The maximum number of items to return. Must be between 1 - 1000 both inclusive.
	Limit *int `json:"limit,omitempty"`

	// Set `cursor` to `next_cursor` returned by the previous call to list items in the next page
	Cursor       *string `json:"cursor,omitempty"`
	TeamId       *string `json:"team_id,omitempty"`
	EnterpriseId *string `json:"enterprise_id,omitempty"`
}

// AdminAppsRequestsListParams defines parameters for AdminAppsRequestsList.
type AdminAppsRequestsListParams struct {
	// Authentication token. Requires scope: `admin.apps:read`
	Token string `json:"token"`

	// The maximum number of items to return. Must be between 1 - 1000 both inclusive.
	Limit *int `json:"limit,omitempty"`

	// Set `cursor` to `next_cursor` returned by the previous call to list items in the next page
	Cursor *string `json:"cursor,omitempty"`
	TeamId *string `json:"team_id,omitempty"`
}

// AdminAppsRestrictJSONBody defines parameters for AdminAppsRestrict.
type AdminAppsRestrictJSONBody struct {
	// The id of the app to restrict.
	AppId *string `json:"app_id,omitempty"`

	// The id of the request to restrict.
	RequestId *string `json:"request_id,omitempty"`
	TeamId    *string `json:"team_id,omitempty"`
}

// AdminAppsRestrictParams defines parameters for AdminAppsRestrict.
type AdminAppsRestrictParams struct {
	// Authentication token. Requires scope: `admin.apps:write`
	Token string `json:"token"`
}

// AdminAppsRestrictedListParams defines parameters for AdminAppsRestrictedList.
type AdminAppsRestrictedListParams struct {
	// Authentication token. Requires scope: `admin.apps:read`
	Token string `json:"token"`

	// The maximum number of items to return. Must be between 1 - 1000 both inclusive.
	Limit *int `json:"limit,omitempty"`

	// Set `cursor` to `next_cursor` returned by the previous call to list items in the next page
	Cursor       *string `json:"cursor,omitempty"`
	TeamId       *string `json:"team_id,omitempty"`
	EnterpriseId *string `json:"enterprise_id,omitempty"`
}

// AdminConversationsArchiveJSONBody defines parameters for AdminConversationsArchive.
type AdminConversationsArchiveJSONBody struct {
	// The channel to archive.
	ChannelId string `json:"channel_id"`
}

// AdminConversationsArchiveParams defines parameters for AdminConversationsArchive.
type AdminConversationsArchiveParams struct {
	// Authentication token. Requires scope: `admin.conversations:write`
	Token string `json:"token"`
}

// AdminConversationsConvertToPrivateJSONBody defines parameters for AdminConversationsConvertToPrivate.
type AdminConversationsConvertToPrivateJSONBody struct {
	// The channel to convert to private.
	ChannelId string `json:"channel_id"`
}

// AdminConversationsConvertToPrivateParams defines parameters for AdminConversationsConvertToPrivate.
type AdminConversationsConvertToPrivateParams struct {
	// Authentication token. Requires scope: `admin.conversations:write`
	Token string `json:"token"`
}

// AdminConversationsCreateJSONBody defines parameters for AdminConversationsCreate.
type AdminConversationsCreateJSONBody struct {
	// Description of the public or private channel to create.
	Description *string `json:"description,omitempty"`

	// When `true`, creates a private channel instead of a public channel
	IsPrivate bool `json:"is_private"`

	// Name of the public or private channel to create.
	Name string `json:"name"`

	// When `true`, the channel will be available org-wide. Note: if the channel is not `org_wide=true`, you must specify a `team_id` for this channel
	OrgWide *bool `json:"org_wide,omitempty"`

	// The workspace to create the channel in. Note: this argument is required unless you set `org_wide=true`.
	TeamId *string `json:"team_id,omitempty"`
}

// AdminConversationsCreateParams defines parameters for AdminConversationsCreate.
type AdminConversationsCreateParams struct {
	// Authentication token. Requires scope: `admin.conversations:write`
	Token string `json:"token"`
}

// AdminConversationsDeleteJSONBody defines parameters for AdminConversationsDelete.
type AdminConversationsDeleteJSONBody struct {
	// The channel to delete.
	ChannelId string `json:"channel_id"`
}

// AdminConversationsDeleteParams defines parameters for AdminConversationsDelete.
type AdminConversationsDeleteParams struct {
	// Authentication token. Requires scope: `admin.conversations:write`
	Token string `json:"token"`
}

// AdminConversationsDisconnectSharedJSONBody defines parameters for AdminConversationsDisconnectShared.
type AdminConversationsDisconnectSharedJSONBody struct {
	// The channel to be disconnected from some workspaces.
	ChannelId string `json:"channel_id"`

	// The team to be removed from the channel. Currently only a single team id can be specified.
	LeavingTeamIds *string `json:"leaving_team_ids,omitempty"`
}

// AdminConversationsDisconnectSharedParams defines parameters for AdminConversationsDisconnectShared.
type AdminConversationsDisconnectSharedParams struct {
	// Authentication token. Requires scope: `admin.conversations:write`
	Token string `json:"token"`
}

// AdminConversationsEkmListOriginalConnectedChannelInfoParams defines parameters for AdminConversationsEkmListOriginalConnectedChannelInfo.
type AdminConversationsEkmListOriginalConnectedChannelInfoParams struct {
	// Authentication token. Requires scope: `admin.conversations:read`
	Token string `json:"token"`

	// A comma-separated list of channels to filter to.
	ChannelIds *string `json:"channel_ids,omitempty"`

	// A comma-separated list of the workspaces to which the channels you would like returned belong.
	TeamIds *string `json:"team_ids,omitempty"`

	// The maximum number of items to return. Must be between 1 - 1000 both inclusive.
	Limit *int `json:"limit,omitempty"`

	// Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
	Cursor *string `json:"cursor,omitempty"`
}

// AdminConversationsGetConversationPrefsParams defines parameters for AdminConversationsGetConversationPrefs.
type AdminConversationsGetConversationPrefsParams struct {
	// The channel to get preferences for.
	ChannelId string `json:"channel_id"`

	// Authentication token. Requires scope: `admin.conversations:read`
	Token string `json:"token"`
}

// AdminConversationsGetTeamsParams defines parameters for AdminConversationsGetTeams.
type AdminConversationsGetTeamsParams struct {
	// The channel to determine connected workspaces within the organization for.
	ChannelId string `json:"channel_id"`

	// Set `cursor` to `next_cursor` returned by the previous call to list items in the next page
	Cursor *string `json:"cursor,omitempty"`

	// The maximum number of items to return. Must be between 1 - 1000 both inclusive.
	Limit *int `json:"limit,omitempty"`

	// Authentication token. Requires scope: `admin.conversations:read`
	Token string `json:"token"`
}

// AdminConversationsInviteJSONBody defines parameters for AdminConversationsInvite.
type AdminConversationsInviteJSONBody struct {
	// The channel that the users will be invited to.
	ChannelId string `json:"channel_id"`

	// The users to invite.
	UserIds string `json:"user_ids"`
}

// AdminConversationsInviteParams defines parameters for AdminConversationsInvite.
type AdminConversationsInviteParams struct {
	// Authentication token. Requires scope: `admin.conversations:write`
	Token string `json:"token"`
}

// AdminConversationsRenameJSONBody defines parameters for AdminConversationsRename.
type AdminConversationsRenameJSONBody struct {
	// The channel to rename.
	ChannelId string `json:"channel_id"`
	Name      string `json:"name"`
}

// AdminConversationsRenameParams defines parameters for AdminConversationsRename.
type AdminConversationsRenameParams struct {
	// Authentication token. Requires scope: `admin.conversations:write`
	Token string `json:"token"`
}

// AdminConversationsRestrictAccessListGroupsParams defines parameters for AdminConversationsRestrictAccessListGroups.
type AdminConversationsRestrictAccessListGroupsParams struct {
	// Authentication token. Requires scope: `admin.conversations:read`
	Token     string `json:"token"`
	ChannelId string `json:"channel_id"`

	// The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization.
	TeamId *string `json:"team_id,omitempty"`
}

// AdminConversationsSearchParams defines parameters for AdminConversationsSearch.
type AdminConversationsSearchParams struct {
	// Comma separated string of team IDs, signifying the workspaces to search through.
	TeamIds *string `json:"team_ids,omitempty"`

	// Name of the the channel to query by.
	Query *string `json:"query,omitempty"`

	// Maximum number of items to be returned. Must be between 1 - 20 both inclusive. Default is 10.
	Limit *int `json:"limit,omitempty"`

	// Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
	Cursor *string `json:"cursor,omitempty"`

	// The type of channel to include or exclude in the search. For example `private` will search private channels, while `private_exclude` will exclude them. For a full list of types, check the [Types section](#types).
	SearchChannelTypes *string `json:"search_channel_types,omitempty"`

	// Possible values are `relevant` (search ranking based on what we think is closest), `name` (alphabetical), `member_count` (number of users in the channel), and `created` (date channel was created). You can optionally pair this with the `sort_dir` arg to change how it is sorted
	Sort *string `json:"sort,omitempty"`

	// Sort direction. Possible values are `asc` for ascending order like (1, 2, 3) or (a, b, c), and `desc` for descending order like (3, 2, 1) or (c, b, a)
	SortDir *string `json:"sort_dir,omitempty"`

	// Authentication token. Requires scope: `admin.conversations:read`
	Token string `json:"token"`
}

// AdminConversationsSetConversationPrefsJSONBody defines parameters for AdminConversationsSetConversationPrefs.
type AdminConversationsSetConversationPrefsJSONBody struct {
	// The channel to set the prefs for
	ChannelId string `json:"channel_id"`

	// The prefs for this channel in a stringified JSON format.
	Prefs string `json:"prefs"`
}

// AdminConversationsSetConversationPrefsParams defines parameters for AdminConversationsSetConversationPrefs.
type AdminConversationsSetConversationPrefsParams struct {
	// Authentication token. Requires scope: `admin.conversations:write`
	Token string `json:"token"`
}

// AdminConversationsSetTeamsJSONBody defines parameters for AdminConversationsSetTeams.
type AdminConversationsSetTeamsJSONBody struct {
	// The encoded `channel_id` to add or remove to workspaces.
	ChannelId string `json:"channel_id"`

	// True if channel has to be converted to an org channel
	OrgChannel *bool `json:"org_channel,omitempty"`

	// A comma-separated list of workspaces to which the channel should be shared. Not required if the channel is being shared org-wide.
	TargetTeamIds *string `json:"target_team_ids,omitempty"`

	// The workspace to which the channel belongs. Omit this argument if the channel is a cross-workspace shared channel.
	TeamId *string `json:"team_id,omitempty"`
}

// AdminConversationsSetTeamsParams defines parameters for AdminConversationsSetTeams.
type AdminConversationsSetTeamsParams struct {
	// Authentication token. Requires scope: `admin.conversations:write`
	Token string `json:"token"`
}

// AdminConversationsUnarchiveJSONBody defines parameters for AdminConversationsUnarchive.
type AdminConversationsUnarchiveJSONBody struct {
	// The channel to unarchive.
	ChannelId string `json:"channel_id"`
}

// AdminConversationsUnarchiveParams defines parameters for AdminConversationsUnarchive.
type AdminConversationsUnarchiveParams struct {
	// Authentication token. Requires scope: `admin.conversations:write`
	Token string `json:"token"`
}

// AdminInviteRequestsApproveJSONBody defines parameters for AdminInviteRequestsApprove.
type AdminInviteRequestsApproveJSONBody struct {
	// ID of the request to invite.
	InviteRequestId string `json:"invite_request_id"`

	// ID for the workspace where the invite request was made.
	TeamId *string `json:"team_id,omitempty"`
}

// AdminInviteRequestsApproveParams defines parameters for AdminInviteRequestsApprove.
type AdminInviteRequestsApproveParams struct {
	// Authentication token. Requires scope: `admin.invites:write`
	Token string `json:"token"`
}

// AdminInviteRequestsApprovedListParams defines parameters for AdminInviteRequestsApprovedList.
type AdminInviteRequestsApprovedListParams struct {
	// ID for the workspace where the invite requests were made.
	TeamId *string `json:"team_id,omitempty"`

	// Value of the `next_cursor` field sent as part of the previous API response
	Cursor *string `json:"cursor,omitempty"`

	// The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive
	Limit *int `json:"limit,omitempty"`

	// Authentication token. Requires scope: `admin.invites:read`
	Token string `json:"token"`
}

// AdminInviteRequestsDeniedListParams defines parameters for AdminInviteRequestsDeniedList.
type AdminInviteRequestsDeniedListParams struct {
	// ID for the workspace where the invite requests were made.
	TeamId *string `json:"team_id,omitempty"`

	// Value of the `next_cursor` field sent as part of the previous api response
	Cursor *string `json:"cursor,omitempty"`

	// The number of results that will be returned by the API on each invocation. Must be between 1 - 1000 both inclusive
	Limit *int `json:"limit,omitempty"`

	// Authentication token. Requires scope: `admin.invites:read`
	Token string `json:"token"`
}

// AdminInviteRequestsDenyJSONBody defines parameters for AdminInviteRequestsDeny.
type AdminInviteRequestsDenyJSONBody struct {
	// ID of the request to invite.
	InviteRequestId string `json:"invite_request_id"`

	// ID for the workspace where the invite request was made.
	TeamId *string `json:"team_id,omitempty"`
}

// AdminInviteRequestsDenyParams defines parameters for AdminInviteRequestsDeny.
type AdminInviteRequestsDenyParams struct {
	// Authentication token. Requires scope: `admin.invites:write`
	Token string `json:"token"`
}

// AdminInviteRequestsListParams defines parameters for AdminInviteRequestsList.
type AdminInviteRequestsListParams struct {
	// ID for the workspace where the invite requests were made.
	TeamId *string `json:"team_id,omitempty"`

	// Value of the `next_cursor` field sent as part of the previous API response
	Cursor *string `json:"cursor,omitempty"`

	// The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive
	Limit *int `json:"limit,omitempty"`

	// Authentication token. Requires scope: `admin.invites:read`
	Token string `json:"token"`
}

// AdminTeamsAdminsListParams defines parameters for AdminTeamsAdminsList.
type AdminTeamsAdminsListParams struct {
	// Authentication token. Requires scope: `admin.teams:read`
	Token string `json:"token"`

	// The maximum number of items to return.
	Limit *int `json:"limit,omitempty"`

	// Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
	Cursor *string `json:"cursor,omitempty"`
	TeamId string  `json:"team_id"`
}

// AdminTeamsCreateJSONBody defines parameters for AdminTeamsCreate.
type AdminTeamsCreateJSONBody struct {
	// Description for the team.
	TeamDescription *string `json:"team_description,omitempty"`

	// Who can join the team. A team's discoverability can be `open`, `closed`, `invite_only`, or `unlisted`.
	TeamDiscoverability *string `json:"team_discoverability,omitempty"`

	// Team domain (for example, slacksoftballteam).
	TeamDomain string `json:"team_domain"`

	// Team name (for example, Slack Softball Team).
	TeamName string `json:"team_name"`
}

// AdminTeamsCreateParams defines parameters for AdminTeamsCreate.
type AdminTeamsCreateParams struct {
	// Authentication token. Requires scope: `admin.teams:write`
	Token string `json:"token"`
}

// AdminTeamsListParams defines parameters for AdminTeamsList.
type AdminTeamsListParams struct {
	// The maximum number of items to return. Must be between 1 - 100 both inclusive.
	Limit *int `json:"limit,omitempty"`

	// Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
	Cursor *string `json:"cursor,omitempty"`

	// Authentication token. Requires scope: `admin.teams:read`
	Token string `json:"token"`
}

// AdminTeamsOwnersListParams defines parameters for AdminTeamsOwnersList.
type AdminTeamsOwnersListParams struct {
	// Authentication token. Requires scope: `admin.teams:read`
	Token  string `json:"token"`
	TeamId string `json:"team_id"`

	// The maximum number of items to return. Must be between 1 - 1000 both inclusive.
	Limit *int `json:"limit,omitempty"`

	// Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
	Cursor *string `json:"cursor,omitempty"`
}

// AdminTeamsSettingsInfoParams defines parameters for AdminTeamsSettingsInfo.
type AdminTeamsSettingsInfoParams struct {
	TeamId string `json:"team_id"`

	// Authentication token. Requires scope: `admin.teams:read`
	Token string `json:"token"`
}

// AdminTeamsSettingsSetDescriptionJSONBody defines parameters for AdminTeamsSettingsSetDescription.
type AdminTeamsSettingsSetDescriptionJSONBody struct {
	// The new description for the workspace.
	Description string `json:"description"`

	// ID for the workspace to set the description for.
	TeamId string `json:"team_id"`
}

// AdminTeamsSettingsSetDescriptionParams defines parameters for AdminTeamsSettingsSetDescription.
type AdminTeamsSettingsSetDescriptionParams struct {
	// Authentication token. Requires scope: `admin.teams:write`
	Token string `json:"token"`
}

// AdminTeamsSettingsSetDiscoverabilityJSONBody defines parameters for AdminTeamsSettingsSetDiscoverability.
type AdminTeamsSettingsSetDiscoverabilityJSONBody struct {
	// This workspace's discovery setting. It must be set to one of `open`, `invite_only`, `closed`, or `unlisted`.
	Discoverability string `json:"discoverability"`

	// The ID of the workspace to set discoverability on.
	TeamId string `json:"team_id"`
}

// AdminTeamsSettingsSetDiscoverabilityParams defines parameters for AdminTeamsSettingsSetDiscoverability.
type AdminTeamsSettingsSetDiscoverabilityParams struct {
	// Authentication token. Requires scope: `admin.teams:write`
	Token string `json:"token"`
}

// AdminTeamsSettingsSetNameJSONBody defines parameters for AdminTeamsSettingsSetName.
type AdminTeamsSettingsSetNameJSONBody struct {
	// The new name of the workspace.
	Name string `json:"name"`

	// ID for the workspace to set the name for.
	TeamId string `json:"team_id"`
}

// AdminTeamsSettingsSetNameParams defines parameters for AdminTeamsSettingsSetName.
type AdminTeamsSettingsSetNameParams struct {
	// Authentication token. Requires scope: `admin.teams:write`
	Token string `json:"token"`
}

// AdminUsergroupsAddChannelsJSONBody defines parameters for AdminUsergroupsAddChannels.
type AdminUsergroupsAddChannelsJSONBody struct {
	// Comma separated string of channel IDs.
	ChannelIds string `json:"channel_ids"`

	// The workspace to add default channels in.
	TeamId *string `json:"team_id,omitempty"`

	// ID of the IDP group to add default channels for.
	UsergroupId string `json:"usergroup_id"`
}

// AdminUsergroupsAddChannelsParams defines parameters for AdminUsergroupsAddChannels.
type AdminUsergroupsAddChannelsParams struct {
	// Authentication token. Requires scope: `admin.usergroups:write`
	Token string `json:"token"`
}

// AdminUsergroupsAddTeamsJSONBody defines parameters for AdminUsergroupsAddTeams.
type AdminUsergroupsAddTeamsJSONBody struct {
	// When `true`, this method automatically creates new workspace accounts for the IDP group members.
	AutoProvision *bool `json:"auto_provision,omitempty"`

	// A comma separated list of encoded team (workspace) IDs. Each workspace *MUST* belong to the organization associated with the token.
	TeamIds string `json:"team_ids"`

	// An encoded usergroup (IDP Group) ID.
	UsergroupId string `json:"usergroup_id"`
}

// AdminUsergroupsAddTeamsParams defines parameters for AdminUsergroupsAddTeams.
type AdminUsergroupsAddTeamsParams struct {
	// Authentication token. Requires scope: `admin.teams:write`
	Token string `json:"token"`
}

// AdminUsergroupsListChannelsParams defines parameters for AdminUsergroupsListChannels.
type AdminUsergroupsListChannelsParams struct {
	// ID of the IDP group to list default channels for.
	UsergroupId string `json:"usergroup_id"`

	// ID of the the workspace.
	TeamId *string `json:"team_id,omitempty"`

	// Flag to include or exclude the count of members per channel.
	IncludeNumMembers *bool `json:"include_num_members,omitempty"`

	// Authentication token. Requires scope: `admin.usergroups:read`
	Token string `json:"token"`
}

// AdminUsergroupsRemoveChannelsJSONBody defines parameters for AdminUsergroupsRemoveChannels.
type AdminUsergroupsRemoveChannelsJSONBody struct {
	// Comma-separated string of channel IDs
	ChannelIds string `json:"channel_ids"`

	// ID of the IDP Group
	UsergroupId string `json:"usergroup_id"`
}

// AdminUsergroupsRemoveChannelsParams defines parameters for AdminUsergroupsRemoveChannels.
type AdminUsergroupsRemoveChannelsParams struct {
	// Authentication token. Requires scope: `admin.usergroups:write`
	Token string `json:"token"`
}

// AdminUsersAssignJSONBody defines parameters for AdminUsersAssign.
type AdminUsersAssignJSONBody struct {
	// Comma separated values of channel IDs to add user in the new workspace.
	ChannelIds *string `json:"channel_ids,omitempty"`

	// True if user should be added to the workspace as a guest.
	IsRestricted *bool `json:"is_restricted,omitempty"`

	// True if user should be added to the workspace as a single-channel guest.
	IsUltraRestricted *bool `json:"is_ultra_restricted,omitempty"`

	// The ID (`T1234`) of the workspace.
	TeamId string `json:"team_id"`

	// The ID of the user to add to the workspace.
	UserId string `json:"user_id"`
}

// AdminUsersAssignParams defines parameters for AdminUsersAssign.
type AdminUsersAssignParams struct {
	// Authentication token. Requires scope: `admin.users:write`
	Token string `json:"token"`
}

// AdminUsersInviteJSONBody defines parameters for AdminUsersInvite.
type AdminUsersInviteJSONBody struct {
	// A comma-separated list of `channel_id`s for this user to join. At least one channel is required.
	ChannelIds string `json:"channel_ids"`

	// An optional message to send to the user in the invite email.
	CustomMessage *string `json:"custom_message,omitempty"`

	// The email address of the person to invite.
	Email string `json:"email"`

	// Timestamp when guest account should be disabled. Only include this timestamp if you are inviting a guest user and you want their account to expire on a certain date.
	GuestExpirationTs *string `json:"guest_expiration_ts,omitempty"`

	// Is this user a multi-channel guest user? (default: false)
	IsRestricted *bool `json:"is_restricted,omitempty"`

	// Is this user a single channel guest user? (default: false)
	IsUltraRestricted *bool `json:"is_ultra_restricted,omitempty"`

	// Full name of the user.
	RealName *string `json:"real_name,omitempty"`

	// Allow this invite to be resent in the future if a user has not signed up yet. (default: false)
	Resend *bool `json:"resend,omitempty"`

	// The ID (`T1234`) of the workspace.
	TeamId string `json:"team_id"`
}

// AdminUsersInviteParams defines parameters for AdminUsersInvite.
type AdminUsersInviteParams struct {
	// Authentication token. Requires scope: `admin.users:write`
	Token string `json:"token"`
}

// AdminUsersListParams defines parameters for AdminUsersList.
type AdminUsersListParams struct {
	// The ID (`T1234`) of the workspace.
	TeamId string `json:"team_id"`

	// Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
	Cursor *string `json:"cursor,omitempty"`

	// Limit for how many users to be retrieved per page
	Limit *int `json:"limit,omitempty"`

	// Authentication token. Requires scope: `admin.users:read`
	Token string `json:"token"`
}

// AdminUsersRemoveJSONBody defines parameters for AdminUsersRemove.
type AdminUsersRemoveJSONBody struct {
	// The ID (`T1234`) of the workspace.
	TeamId string `json:"team_id"`

	// The ID of the user to remove.
	UserId string `json:"user_id"`
}

// AdminUsersRemoveParams defines parameters for AdminUsersRemove.
type AdminUsersRemoveParams struct {
	// Authentication token. Requires scope: `admin.users:write`
	Token string `json:"token"`
}

// AdminUsersSessionInvalidateJSONBody defines parameters for AdminUsersSessionInvalidate.
type AdminUsersSessionInvalidateJSONBody struct {
	SessionId int32 `json:"session_id"`

	// ID of the team that the session belongs to
	TeamId string `json:"team_id"`
}

// AdminUsersSessionInvalidateParams defines parameters for AdminUsersSessionInvalidate.
type AdminUsersSessionInvalidateParams struct {
	// Authentication token. Requires scope: `admin.users:write`
	Token string `json:"token"`
}

// AdminUsersSessionResetJSONBody defines parameters for AdminUsersSessionReset.
type AdminUsersSessionResetJSONBody struct {
	// Only expire mobile sessions (default: false)
	MobileOnly *bool `json:"mobile_only,omitempty"`

	// The ID of the user to wipe sessions for
	UserId string `json:"user_id"`

	// Only expire web sessions (default: false)
	WebOnly *bool `json:"web_only,omitempty"`
}

// AdminUsersSessionResetParams defines parameters for AdminUsersSessionReset.
type AdminUsersSessionResetParams struct {
	// Authentication token. Requires scope: `admin.users:write`
	Token string `json:"token"`
}

// AdminUsersSetAdminJSONBody defines parameters for AdminUsersSetAdmin.
type AdminUsersSetAdminJSONBody struct {
	// The ID (`T1234`) of the workspace.
	TeamId string `json:"team_id"`

	// The ID of the user to designate as an admin.
	UserId string `json:"user_id"`
}

// AdminUsersSetAdminParams defines parameters for AdminUsersSetAdmin.
type AdminUsersSetAdminParams struct {
	// Authentication token. Requires scope: `admin.users:write`
	Token string `json:"token"`
}

// AdminUsersSetExpirationJSONBody defines parameters for AdminUsersSetExpiration.
type AdminUsersSetExpirationJSONBody struct {
	// Timestamp when guest account should be disabled.
	ExpirationTs int32 `json:"expiration_ts"`

	// The ID (`T1234`) of the workspace.
	TeamId string `json:"team_id"`

	// The ID of the user to set an expiration for.
	UserId string `json:"user_id"`
}

// AdminUsersSetExpirationParams defines parameters for AdminUsersSetExpiration.
type AdminUsersSetExpirationParams struct {
	// Authentication token. Requires scope: `admin.users:write`
	Token string `json:"token"`
}

// AdminUsersSetOwnerJSONBody defines parameters for AdminUsersSetOwner.
type AdminUsersSetOwnerJSONBody struct {
	// The ID (`T1234`) of the workspace.
	TeamId string `json:"team_id"`

	// Id of the user to promote to owner.
	UserId string `json:"user_id"`
}

// AdminUsersSetOwnerParams defines parameters for AdminUsersSetOwner.
type AdminUsersSetOwnerParams struct {
	// Authentication token. Requires scope: `admin.users:write`
	Token string `json:"token"`
}

// AdminUsersSetRegularJSONBody defines parameters for AdminUsersSetRegular.
type AdminUsersSetRegularJSONBody struct {
	// The ID (`T1234`) of the workspace.
	TeamId string `json:"team_id"`

	// The ID of the user to designate as a regular user.
	UserId string `json:"user_id"`
}

// AdminUsersSetRegularParams defines parameters for AdminUsersSetRegular.
type AdminUsersSetRegularParams struct {
	// Authentication token. Requires scope: `admin.users:write`
	Token string `json:"token"`
}

// ApiTestParams defines parameters for ApiTest.
type ApiTestParams struct {
	// Error response to return
	Error *string `json:"error,omitempty"`

	// example property to return
	Foo *string `json:"foo,omitempty"`
}

// AppsEventAuthorizationsListParams defines parameters for AppsEventAuthorizationsList.
type AppsEventAuthorizationsListParams struct {
	EventContext string  `json:"event_context"`
	Cursor       *string `json:"cursor,omitempty"`
	Limit        *int    `json:"limit,omitempty"`

	// Authentication token. Requires scope: `authorizations:read`
	Token string `json:"token"`
}

// AppsPermissionsInfoParams defines parameters for AppsPermissionsInfo.
type AppsPermissionsInfoParams struct {
	// Authentication token. Requires scope: `none`
	Token *string `json:"token,omitempty"`
}

// AppsPermissionsRequestParams defines parameters for AppsPermissionsRequest.
type AppsPermissionsRequestParams struct {
	// Authentication token. Requires scope: `none`
	Token string `json:"token"`

	// A comma separated list of scopes to request for
	Scopes string `json:"scopes"`

	// Token used to trigger the permissions API
	TriggerId string `json:"trigger_id"`
}

// AppsPermissionsResourcesListParams defines parameters for AppsPermissionsResourcesList.
type AppsPermissionsResourcesListParams struct {
	// Authentication token. Requires scope: `none`
	Token string `json:"token"`

	// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail.
	Cursor *string `json:"cursor,omitempty"`

	// The maximum number of items to return.
	Limit *int `json:"limit,omitempty"`
}

// AppsPermissionsScopesListParams defines parameters for AppsPermissionsScopesList.
type AppsPermissionsScopesListParams struct {
	// Authentication token. Requires scope: `none`
	Token string `json:"token"`
}

// AppsPermissionsUsersListParams defines parameters for AppsPermissionsUsersList.
type AppsPermissionsUsersListParams struct {
	// Authentication token. Requires scope: `none`
	Token string `json:"token"`

	// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail.
	Cursor *string `json:"cursor,omitempty"`

	// The maximum number of items to return.
	Limit *int `json:"limit,omitempty"`
}

// AppsPermissionsUsersRequestParams defines parameters for AppsPermissionsUsersRequest.
type AppsPermissionsUsersRequestParams struct {
	// Authentication token. Requires scope: `none`
	Token string `json:"token"`

	// A comma separated list of user scopes to request for
	Scopes string `json:"scopes"`

	// Token used to trigger the request
	TriggerId string `json:"trigger_id"`

	// The user this scope is being requested for
	User string `json:"user"`
}

// AppsUninstallParams defines parameters for AppsUninstall.
type AppsUninstallParams struct {
	// Authentication token. Requires scope: `none`
	Token *string `json:"token,omitempty"`

	// Issued when you created your application.
	ClientId *string `json:"client_id,omitempty"`

	// Issued when you created your application.
	ClientSecret *string `json:"client_secret,omitempty"`
}

// AuthRevokeParams defines parameters for AuthRevoke.
type AuthRevokeParams struct {
	// Authentication token. Requires scope: `none`
	Token string `json:"token"`

	// Setting this parameter to `1` triggers a _testing mode_ where the specified token will not actually be revoked.
	Test *bool `json:"test,omitempty"`
}

// AuthTestParams defines parameters for AuthTest.
type AuthTestParams struct {
	// Authentication token. Requires scope: `none`
	Token string `json:"token"`
}

// BotsInfoParams defines parameters for BotsInfo.
type BotsInfoParams struct {
	// Authentication token. Requires scope: `users:read`
	Token string `json:"token"`

	// Bot user to get info on
	Bot *string `json:"bot,omitempty"`
}

// CallsAddJSONBody defines parameters for CallsAdd.
type CallsAddJSONBody struct {
	// The valid Slack user ID of the user who created this Call. When this method is called with a user token, the `created_by` field is optional and defaults to the authed user of the token. Otherwise, the field is required.
	CreatedBy *string `json:"created_by,omitempty"`

	// Call start time in UTC UNIX timestamp format
	DateStart *int32 `json:"date_start,omitempty"`

	// When supplied, available Slack clients will attempt to directly launch the 3rd-party Call with this URL.
	DesktopAppJoinUrl *string `json:"desktop_app_join_url,omitempty"`

	// An optional, human-readable ID supplied by the 3rd-party Call provider. If supplied, this ID will be displayed in the Call object.
	ExternalDisplayId *string `json:"external_display_id,omitempty"`

	// An ID supplied by the 3rd-party Call provider. It must be unique across all Calls from that service.
	ExternalUniqueId string `json:"external_unique_id"`

	// The URL required for a client to join the Call.
	JoinUrl string `json:"join_url"`

	// The name of the Call.
	Title *string `json:"title,omitempty"`

	// The list of users to register as participants in the Call. [Read more on how to specify users here](/apis/calls#users).
	Users *string `json:"users,omitempty"`
}

// CallsAddParams defines parameters for CallsAdd.
type CallsAddParams struct {
	// Authentication token. Requires scope: `calls:write`
	Token string `json:"token"`
}

// CallsEndJSONBody defines parameters for CallsEnd.
type CallsEndJSONBody struct {
	// Call duration in seconds
	Duration *int32 `json:"duration,omitempty"`

	// `id` returned when registering the call using the [`calls.add`](/methods/calls.add) method.
	Id string `json:"id"`
}

// CallsEndParams defines parameters for CallsEnd.
type CallsEndParams struct {
	// Authentication token. Requires scope: `calls:write`
	Token string `json:"token"`
}

// CallsInfoParams defines parameters for CallsInfo.
type CallsInfoParams struct {
	// `id` of the Call returned by the [`calls.add`](/methods/calls.add) method.
	Id string `json:"id"`

	// Authentication token. Requires scope: `calls:read`
	Token string `json:"token"`
}

// CallsParticipantsAddJSONBody defines parameters for CallsParticipantsAdd.
type CallsParticipantsAddJSONBody struct {
	// `id` returned by the [`calls.add`](/methods/calls.add) method.
	Id string `json:"id"`

	// The list of users to add as participants in the Call. [Read more on how to specify users here](/apis/calls#users).
	Users string `json:"users"`
}

// CallsParticipantsAddParams defines parameters for CallsParticipantsAdd.
type CallsParticipantsAddParams struct {
	// Authentication token. Requires scope: `calls:write`
	Token string `json:"token"`
}

// CallsParticipantsRemoveJSONBody defines parameters for CallsParticipantsRemove.
type CallsParticipantsRemoveJSONBody struct {
	// `id` returned by the [`calls.add`](/methods/calls.add) method.
	Id string `json:"id"`

	// The list of users to remove as participants in the Call. [Read more on how to specify users here](/apis/calls#users).
	Users string `json:"users"`
}

// CallsParticipantsRemoveParams defines parameters for CallsParticipantsRemove.
type CallsParticipantsRemoveParams struct {
	// Authentication token. Requires scope: `calls:write`
	Token string `json:"token"`
}

// CallsUpdateJSONBody defines parameters for CallsUpdate.
type CallsUpdateJSONBody struct {
	// When supplied, available Slack clients will attempt to directly launch the 3rd-party Call with this URL.
	DesktopAppJoinUrl *string `json:"desktop_app_join_url,omitempty"`

	// `id` returned by the [`calls.add`](/methods/calls.add) method.
	Id string `json:"id"`

	// The URL required for a client to join the Call.
	JoinUrl *string `json:"join_url,omitempty"`

	// The name of the Call.
	Title *string `json:"title,omitempty"`
}

// CallsUpdateParams defines parameters for CallsUpdate.
type CallsUpdateParams struct {
	// Authentication token. Requires scope: `calls:write`
	Token string `json:"token"`
}

// ChatDeleteJSONBody defines parameters for ChatDelete.
type ChatDeleteJSONBody struct {
	// Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.
	AsUser *bool `json:"as_user,omitempty"`

	// Channel containing the message to be deleted.
	Channel *string `json:"channel,omitempty"`

	// Timestamp of the message to be deleted.
	Ts *float32 `json:"ts,omitempty"`
}

// ChatDeleteParams defines parameters for ChatDelete.
type ChatDeleteParams struct {
	// Authentication token. Requires scope: `chat:write`
	Token *string `json:"token,omitempty"`
}

// ChatDeleteScheduledMessageJSONBody defines parameters for ChatDeleteScheduledMessage.
type ChatDeleteScheduledMessageJSONBody struct {
	// Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.
	AsUser *bool `json:"as_user,omitempty"`

	// The channel the scheduled_message is posting to
	Channel string `json:"channel"`

	// `scheduled_message_id` returned from call to chat.scheduleMessage
	ScheduledMessageId string `json:"scheduled_message_id"`
}

// ChatDeleteScheduledMessageParams defines parameters for ChatDeleteScheduledMessage.
type ChatDeleteScheduledMessageParams struct {
	// Authentication token. Requires scope: `chat:write`
	Token string `json:"token"`
}

// ChatGetPermalinkParams defines parameters for ChatGetPermalink.
type ChatGetPermalinkParams struct {
	// Authentication token. Requires scope: `none`
	Token string `json:"token"`

	// The ID of the conversation or channel containing the message
	Channel string `json:"channel"`

	// A message's `ts` value, uniquely identifying it within a channel
	MessageTs string `json:"message_ts"`
}

// ChatMeMessageJSONBody defines parameters for ChatMeMessage.
type ChatMeMessageJSONBody struct {
	// Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
	Channel *string `json:"channel,omitempty"`

	// Text of the message to send.
	Text *string `json:"text,omitempty"`
}

// ChatMeMessageParams defines parameters for ChatMeMessage.
type ChatMeMessageParams struct {
	// Authentication token. Requires scope: `chat:write`
	Token *string `json:"token,omitempty"`
}

// ChatPostEphemeralJSONBody defines parameters for ChatPostEphemeral.
type ChatPostEphemeralJSONBody struct {
	// Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.
	AsUser *bool `json:"as_user,omitempty"`

	// A JSON-based array of structured attachments, presented as a URL-encoded string.
	Attachments *string `json:"attachments,omitempty"`

	// A JSON-based array of structured blocks, presented as a URL-encoded string.
	Blocks *string `json:"blocks,omitempty"`

	// Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.
	Channel string `json:"channel"`

	// Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.
	IconEmoji *string `json:"icon_emoji,omitempty"`

	// URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
	IconUrl *string `json:"icon_url,omitempty"`

	// Find and link channel names and usernames.
	LinkNames *bool `json:"link_names,omitempty"`

	// Change how messages are treated. Defaults to `none`. See [below](#formatting).
	Parse *string `json:"parse,omitempty"`

	// How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
	Text *string `json:"text,omitempty"`

	// Provide another message's `ts` value to post this message in a thread. Avoid using a reply's `ts` value; use its parent's value instead. Ephemeral messages in threads are only shown if there is already an active thread.
	ThreadTs *string `json:"thread_ts,omitempty"`

	// `id` of the user who will receive the ephemeral message. The user should be in the channel specified by the `channel` argument.
	User string `json:"user"`

	// Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
	Username *string `json:"username,omitempty"`
}

// ChatPostEphemeralParams defines parameters for ChatPostEphemeral.
type ChatPostEphemeralParams struct {
	// Authentication token. Requires scope: `chat:write`
	Token string `json:"token"`
}

// ChatPostMessageJSONBody defines parameters for ChatPostMessage.
type ChatPostMessageJSONBody struct {
	// Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](#authorship) below.
	AsUser *string `json:"as_user,omitempty"`

	// A JSON-based array of structured attachments, presented as a URL-encoded string.
	Attachments *string `json:"attachments,omitempty"`

	// A JSON-based array of structured blocks, presented as a URL-encoded string.
	Blocks *string `json:"blocks,omitempty"`

	// Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.
	Channel string `json:"channel"`

	// Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.
	IconEmoji *string `json:"icon_emoji,omitempty"`

	// URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
	IconUrl *string `json:"icon_url,omitempty"`

	// Find and link channel names and usernames.
	LinkNames *bool `json:"link_names,omitempty"`

	// Disable Slack markup parsing by setting to `false`. Enabled by default.
	Mrkdwn *bool `json:"mrkdwn,omitempty"`

	// Change how messages are treated. Defaults to `none`. See [below](#formatting).
	Parse *string `json:"parse,omitempty"`

	// Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.
	ReplyBroadcast *bool `json:"reply_broadcast,omitempty"`

	// How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
	Text *string `json:"text,omitempty"`

	// Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.
	ThreadTs *string `json:"thread_ts,omitempty"`

	// Pass true to enable unfurling of primarily text-based content.
	UnfurlLinks *bool `json:"unfurl_links,omitempty"`

	// Pass false to disable unfurling of media content.
	UnfurlMedia *bool `json:"unfurl_media,omitempty"`

	// Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
	Username *string `json:"username,omitempty"`
}

// ChatPostMessageParams defines parameters for ChatPostMessage.
type ChatPostMessageParams struct {
	// Authentication token. Requires scope: `chat:write`
	Token string `json:"token"`
}

// ChatScheduleMessageJSONBody defines parameters for ChatScheduleMessage.
type ChatScheduleMessageJSONBody struct {
	// Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship).
	AsUser *bool `json:"as_user,omitempty"`

	// A JSON-based array of structured attachments, presented as a URL-encoded string.
	Attachments *string `json:"attachments,omitempty"`

	// A JSON-based array of structured blocks, presented as a URL-encoded string.
	Blocks *string `json:"blocks,omitempty"`

	// Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.
	Channel *string `json:"channel,omitempty"`

	// Find and link channel names and usernames.
	LinkNames *bool `json:"link_names,omitempty"`

	// Change how messages are treated. Defaults to `none`. See [chat.postMessage](chat.postMessage#formatting).
	Parse *string `json:"parse,omitempty"`

	// Unix EPOCH timestamp of time in future to send the message.
	PostAt *string `json:"post_at,omitempty"`

	// Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.
	ReplyBroadcast *bool `json:"reply_broadcast,omitempty"`

	// How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
	Text *string `json:"text,omitempty"`

	// Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.
	ThreadTs *float32 `json:"thread_ts,omitempty"`

	// Pass true to enable unfurling of primarily text-based content.
	UnfurlLinks *bool `json:"unfurl_links,omitempty"`

	// Pass false to disable unfurling of media content.
	UnfurlMedia *bool `json:"unfurl_media,omitempty"`
}

// ChatScheduleMessageParams defines parameters for ChatScheduleMessage.
type ChatScheduleMessageParams struct {
	// Authentication token. Requires scope: `chat:write`
	Token *string `json:"token,omitempty"`
}

// ChatScheduledMessagesListParams defines parameters for ChatScheduledMessagesList.
type ChatScheduledMessagesListParams struct {
	// The channel of the scheduled messages
	Channel *string `json:"channel,omitempty"`

	// A UNIX timestamp of the latest value in the time range
	Latest *float32 `json:"latest,omitempty"`

	// A UNIX timestamp of the oldest value in the time range
	Oldest *float32 `json:"oldest,omitempty"`

	// Maximum number of original entries to return.
	Limit *int `json:"limit,omitempty"`

	// For pagination purposes, this is the `cursor` value returned from a previous call to `chat.scheduledmessages.list` indicating where you want to start this call from.
	Cursor *string `json:"cursor,omitempty"`

	// Authentication token. Requires scope: `none`
	Token *string `json:"token,omitempty"`
}

// ChatUnfurlJSONBody defines parameters for ChatUnfurl.
type ChatUnfurlJSONBody struct {
	// Channel ID of the message
	Channel string `json:"channel"`

	// Timestamp of the message to add unfurl behavior to.
	Ts string `json:"ts"`

	// URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.
	Unfurls *string `json:"unfurls,omitempty"`

	// Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior
	UserAuthMessage *string `json:"user_auth_message,omitempty"`

	// Set to `true` or `1` to indicate the user must install your Slack app to trigger unfurls for this domain
	UserAuthRequired *bool `json:"user_auth_required,omitempty"`

	// Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
	UserAuthUrl *string `json:"user_auth_url,omitempty"`
}

// ChatUnfurlParams defines parameters for ChatUnfurl.
type ChatUnfurlParams struct {
	// Authentication token. Requires scope: `links:write`
	Token string `json:"token"`
}

// ChatUpdateJSONBody defines parameters for ChatUpdate.
type ChatUpdateJSONBody struct {
	// Pass true to update the message as the authed user. [Bot users](/bot-users) in this context are considered authed users.
	AsUser *string `json:"as_user,omitempty"`

	// A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting `text`. If you don't include this field, the message's previous `attachments` will be retained. To remove previous `attachments`, include an empty array for this field.
	Attachments *string `json:"attachments,omitempty"`

	// A JSON-based array of [structured blocks](/block-kit/building), presented as a URL-encoded string. If you don't include this field, the message's previous `blocks` will be retained. To remove previous `blocks`, include an empty array for this field.
	Blocks *string `json:"blocks,omitempty"`

	// Channel containing the message to be updated.
	Channel string `json:"channel"`

	// Find and link channel names and usernames. Defaults to `none`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `none`.
	LinkNames *string `json:"link_names,omitempty"`

	// Change how messages are treated. Defaults to `client`, unlike `chat.postMessage`. Accepts either `none` or `full`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `client`.
	Parse *string `json:"parse,omitempty"`

	// New text for the message, using the [default formatting rules](/reference/surfaces/formatting). It's not required when presenting `blocks` or `attachments`.
	Text *string `json:"text,omitempty"`

	// Timestamp of the message to be updated.
	Ts string `json:"ts"`
}

// ChatUpdateParams defines parameters for ChatUpdate.
type ChatUpdateParams struct {
	// Authentication token. Requires scope: `chat:write`
	Token string `json:"token"`
}

// ConversationsArchiveJSONBody defines parameters for ConversationsArchive.
type ConversationsArchiveJSONBody struct {
	// ID of conversation to archive
	Channel *string `json:"channel,omitempty"`
}

// ConversationsArchiveParams defines parameters for ConversationsArchive.
type ConversationsArchiveParams struct {
	// Authentication token. Requires scope: `conversations:write`
	Token *string `json:"token,omitempty"`
}

// ConversationsCloseJSONBody defines parameters for ConversationsClose.
type ConversationsCloseJSONBody struct {
	// Conversation to close.
	Channel *string `json:"channel,omitempty"`
}

// ConversationsCloseParams defines parameters for ConversationsClose.
type ConversationsCloseParams struct {
	// Authentication token. Requires scope: `conversations:write`
	Token *string `json:"token,omitempty"`
}

// ConversationsCreateJSONBody defines parameters for ConversationsCreate.
type ConversationsCreateJSONBody struct {
	// Create a private channel instead of a public one
	IsPrivate *bool `json:"is_private,omitempty"`

	// Name of the public or private channel to create
	Name *string `json:"name,omitempty"`
}

// ConversationsCreateParams defines parameters for ConversationsCreate.
type ConversationsCreateParams struct {
	// Authentication token. Requires scope: `conversations:write`
	Token *string `json:"token,omitempty"`
}

// ConversationsHistoryParams defines parameters for ConversationsHistory.
type ConversationsHistoryParams struct {
	// Authentication token. Requires scope: `conversations:history`
	Token *string `json:"token,omitempty"`

	// Conversation ID to fetch history for.
	Channel *string `json:"channel,omitempty"`

	// End of time range of messages to include in results.
	Latest *float32 `json:"latest,omitempty"`

	// Start of time range of messages to include in results.
	Oldest *float32 `json:"oldest,omitempty"`

	// Include messages with latest or oldest timestamp in results only when either timestamp is specified.
	Inclusive *bool `json:"inclusive,omitempty"`

	// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached.
	Limit *int `json:"limit,omitempty"`

	// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail.
	Cursor *string `json:"cursor,omitempty"`
}

// ConversationsInfoParams defines parameters for ConversationsInfo.
type ConversationsInfoParams struct {
	// Authentication token. Requires scope: `conversations:read`
	Token *string `json:"token,omitempty"`

	// Conversation ID to learn more about
	Channel *string `json:"channel,omitempty"`

	// Set this to `true` to receive the locale for this conversation. Defaults to `false`
	IncludeLocale *bool `json:"include_locale,omitempty"`

	// Set to `true` to include the member count for the specified conversation. Defaults to `false`
	IncludeNumMembers *bool `json:"include_num_members,omitempty"`
}

// ConversationsInviteJSONBody defines parameters for ConversationsInvite.
type ConversationsInviteJSONBody struct {
	// The ID of the public or private channel to invite user(s) to.
	Channel *string `json:"channel,omitempty"`

	// A comma separated list of user IDs. Up to 1000 users may be listed.
	Users *string `json:"users,omitempty"`
}

// ConversationsInviteParams defines parameters for ConversationsInvite.
type ConversationsInviteParams struct {
	// Authentication token. Requires scope: `conversations:write`
	Token *string `json:"token,omitempty"`
}

// ConversationsJoinJSONBody defines parameters for ConversationsJoin.
type ConversationsJoinJSONBody struct {
	// ID of conversation to join
	Channel *string `json:"channel,omitempty"`
}

// ConversationsJoinParams defines parameters for ConversationsJoin.
type ConversationsJoinParams struct {
	// Authentication token. Requires scope: `channels:write`
	Token *string `json:"token,omitempty"`
}

// ConversationsKickJSONBody defines parameters for ConversationsKick.
type ConversationsKickJSONBody struct {
	// ID of conversation to remove user from.
	Channel *string `json:"channel,omitempty"`

	// User ID to be removed.
	User *string `json:"user,omitempty"`
}

// ConversationsKickParams defines parameters for ConversationsKick.
type ConversationsKickParams struct {
	// Authentication token. Requires scope: `conversations:write`
	Token *string `json:"token,omitempty"`
}

// ConversationsLeaveJSONBody defines parameters for ConversationsLeave.
type ConversationsLeaveJSONBody struct {
	// Conversation to leave
	Channel *string `json:"channel,omitempty"`
}

// ConversationsLeaveParams defines parameters for ConversationsLeave.
type ConversationsLeaveParams struct {
	// Authentication token. Requires scope: `conversations:write`
	Token *string `json:"token,omitempty"`
}

// ConversationsListParams defines parameters for ConversationsList.
type ConversationsListParams struct {
	// Authentication token. Requires scope: `conversations:read`
	Token *string `json:"token,omitempty"`

	// Set to `true` to exclude archived channels from the list
	ExcludeArchived *bool `json:"exclude_archived,omitempty"`

	// Mix and match channel types by providing a comma-separated list of any combination of `public_channel`, `private_channel`, `mpim`, `im`
	Types *[]ConversationsListConversationType `json:"types,omitempty"`

	// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. Must be an integer no larger than 1000.
	Limit *int `json:"limit,omitempty"`

	// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail.
	Cursor *string `json:"cursor,omitempty"`
}

// ConversationsMarkJSONBody defines parameters for ConversationsMark.
type ConversationsMarkJSONBody struct {
	// Channel or conversation to set the read cursor for.
	Channel *string `json:"channel,omitempty"`

	// Unique identifier of message you want marked as most recently seen in this conversation.
	Ts *float32 `json:"ts,omitempty"`
}

// ConversationsMarkParams defines parameters for ConversationsMark.
type ConversationsMarkParams struct {
	// Authentication token. Requires scope: `conversations:write`
	Token *string `json:"token,omitempty"`
}

// ConversationsMembersParams defines parameters for ConversationsMembers.
type ConversationsMembersParams struct {
	// Authentication token. Requires scope: `conversations:read`
	Token *string `json:"token,omitempty"`

	// ID of the conversation to retrieve members for
	Channel *string `json:"channel,omitempty"`

	// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached.
	Limit *int `json:"limit,omitempty"`

	// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail.
	Cursor *string `json:"cursor,omitempty"`
}

// ConversationsOpenJSONBody defines parameters for ConversationsOpen.
type ConversationsOpenJSONBody struct {
	// Resume a conversation by supplying an `im` or `mpim`'s ID. Or provide the `users` field instead.
	Channel *string `json:"channel,omitempty"`

	// Boolean, indicates you want the full IM channel definition in the response.
	ReturnIm *bool `json:"return_im,omitempty"`

	// Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a `channel` when not supplying `users`.
	Users *string `json:"users,omitempty"`
}

// ConversationsOpenParams defines parameters for ConversationsOpen.
type ConversationsOpenParams struct {
	// Authentication token. Requires scope: `conversations:write`
	Token *string `json:"token,omitempty"`
}

// ConversationsRenameJSONBody defines parameters for ConversationsRename.
type ConversationsRenameJSONBody struct {
	// ID of conversation to rename
	Channel *string `json:"channel,omitempty"`

	// New name for conversation.
	Name *string `json:"name,omitempty"`
}

// ConversationsRenameParams defines parameters for ConversationsRename.
type ConversationsRenameParams struct {
	// Authentication token. Requires scope: `conversations:write`
	Token *string `json:"token,omitempty"`
}

// ConversationsRepliesParams defines parameters for ConversationsReplies.
type ConversationsRepliesParams struct {
	// Authentication token. Requires scope: `conversations:history`
	Token *string `json:"token,omitempty"`

	// Conversation ID to fetch thread from.
	Channel *string `json:"channel,omitempty"`

	// Unique identifier of a thread's parent message. `ts` must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by `ts` will return - it is just an ordinary, unthreaded message.
	Ts *float32 `json:"ts,omitempty"`

	// End of time range of messages to include in results.
	Latest *float32 `json:"latest,omitempty"`

	// Start of time range of messages to include in results.
	Oldest *float32 `json:"oldest,omitempty"`

	// Include messages with latest or oldest timestamp in results only when either timestamp is specified.
	Inclusive *bool `json:"inclusive,omitempty"`

	// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached.
	Limit *int `json:"limit,omitempty"`

	// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail.
	Cursor *string `json:"cursor,omitempty"`
}

// ConversationsSetPurposeJSONBody defines parameters for ConversationsSetPurpose.
type ConversationsSetPurposeJSONBody struct {
	// Conversation to set the purpose of
	Channel *string `json:"channel,omitempty"`

	// A new, specialer purpose
	Purpose *string `json:"purpose,omitempty"`
}

// ConversationsSetPurposeParams defines parameters for ConversationsSetPurpose.
type ConversationsSetPurposeParams struct {
	// Authentication token. Requires scope: `conversations:write`
	Token *string `json:"token,omitempty"`
}

// ConversationsSetTopicJSONBody defines parameters for ConversationsSetTopic.
type ConversationsSetTopicJSONBody struct {
	// Conversation to set the topic of
	Channel *string `json:"channel,omitempty"`

	// The new topic string. Does not support formatting or linkification.
	Topic *string `json:"topic,omitempty"`
}

// ConversationsSetTopicParams defines parameters for ConversationsSetTopic.
type ConversationsSetTopicParams struct {
	// Authentication token. Requires scope: `conversations:write`
	Token *string `json:"token,omitempty"`
}

// ConversationsUnarchiveJSONBody defines parameters for ConversationsUnarchive.
type ConversationsUnarchiveJSONBody struct {
	// ID of conversation to unarchive
	Channel *string `json:"channel,omitempty"`
}

// ConversationsUnarchiveParams defines parameters for ConversationsUnarchive.
type ConversationsUnarchiveParams struct {
	// Authentication token. Requires scope: `conversations:write`
	Token *string `json:"token,omitempty"`
}

// DialogOpenParams defines parameters for DialogOpen.
type DialogOpenParams struct {
	// The dialog definition. This must be a JSON-encoded string.
	Dialog string `json:"dialog"`

	// Exchange a trigger to post to the user.
	TriggerId string `json:"trigger_id"`

	// Authentication token. Requires scope: `none`
	Token string `json:"token"`
}

// DndEndDndParams defines parameters for DndEndDnd.
type DndEndDndParams struct {
	// Authentication token. Requires scope: `dnd:write`
	Token string `json:"token"`
}

// DndEndSnoozeParams defines parameters for DndEndSnooze.
type DndEndSnoozeParams struct {
	// Authentication token. Requires scope: `dnd:write`
	Token string `json:"token"`
}

// DndInfoParams defines parameters for DndInfo.
type DndInfoParams struct {
	// Authentication token. Requires scope: `dnd:read`
	Token *string `json:"token,omitempty"`

	// User to fetch status for (defaults to current user)
	User *string `json:"user,omitempty"`
}

// DndTeamInfoParams defines parameters for DndTeamInfo.
type DndTeamInfoParams struct {
	// Authentication token. Requires scope: `dnd:read`
	Token *string `json:"token,omitempty"`

	// Comma-separated list of users to fetch Do Not Disturb status for
	Users *string `json:"users,omitempty"`
}

// FilesCommentsDeleteJSONBody defines parameters for FilesCommentsDelete.
type FilesCommentsDeleteJSONBody struct {
	// File to delete a comment from.
	File *string `json:"file,omitempty"`

	// The comment to delete.
	Id *string `json:"id,omitempty"`
}

// FilesCommentsDeleteParams defines parameters for FilesCommentsDelete.
type FilesCommentsDeleteParams struct {
	// Authentication token. Requires scope: `files:write:user`
	Token *string `json:"token,omitempty"`
}

// FilesDeleteJSONBody defines parameters for FilesDelete.
type FilesDeleteJSONBody struct {
	// ID of file to delete.
	File *string `json:"file,omitempty"`
}

// FilesDeleteParams defines parameters for FilesDelete.
type FilesDeleteParams struct {
	// Authentication token. Requires scope: `files:write:user`
	Token *string `json:"token,omitempty"`
}

// FilesInfoParams defines parameters for FilesInfo.
type FilesInfoParams struct {
	// Authentication token. Requires scope: `files:read`
	Token *string `json:"token,omitempty"`

	// Specify a file by providing its ID.
	File  *string `json:"file,omitempty"`
	Count *string `json:"count,omitempty"`
	Page  *string `json:"page,omitempty"`

	// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached.
	Limit *int `json:"limit,omitempty"`

	// Parameter for pagination. File comments are paginated for a single file. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first "page" of the collection of comments. See [pagination](/docs/pagination) for more details.
	Cursor *string `json:"cursor,omitempty"`
}

// FilesListParams defines parameters for FilesList.
type FilesListParams struct {
	// Authentication token. Requires scope: `files:read`
	Token *string `json:"token,omitempty"`

	// Filter files created by a single user.
	User *string `json:"user,omitempty"`

	// Filter files appearing in a specific channel, indicated by its ID.
	Channel *string `json:"channel,omitempty"`

	// Filter files created after this timestamp (inclusive).
	TsFrom *float32 `json:"ts_from,omitempty"`

	// Filter files created before this timestamp (inclusive).
	TsTo *float32 `json:"ts_to,omitempty"`

	// Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like `types=spaces,snippets`.The default value is `all`, which does not filter the list.
	Types *string `json:"types,omitempty"`
	Count *string `json:"count,omitempty"`
	Page  *string `json:"page,omitempty"`

	// Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit.
	ShowFilesHiddenByLimit *bool `json:"show_files_hidden_by_limit,omitempty"`
}

// FilesRemoteInfoParams defines parameters for FilesRemoteInfo.
type FilesRemoteInfoParams struct {
	// Authentication token. Requires scope: `remote_files:read`
	Token *string `json:"token,omitempty"`

	// Specify a file by providing its ID.
	File *string `json:"file,omitempty"`

	// Creator defined GUID for the file.
	ExternalId *string `json:"external_id,omitempty"`
}

// FilesRemoteListParams defines parameters for FilesRemoteList.
type FilesRemoteListParams struct {
	// Authentication token. Requires scope: `remote_files:read`
	Token *string `json:"token,omitempty"`

	// Filter files appearing in a specific channel, indicated by its ID.
	Channel *string `json:"channel,omitempty"`

	// Filter files created after this timestamp (inclusive).
	TsFrom *float32 `json:"ts_from,omitempty"`

	// Filter files created before this timestamp (inclusive).
	TsTo *float32 `json:"ts_to,omitempty"`

	// The maximum number of items to return.
	Limit *int `json:"limit,omitempty"`

	// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail.
	Cursor *string `json:"cursor,omitempty"`
}

// FilesRemoteShareParams defines parameters for FilesRemoteShare.
type FilesRemoteShareParams struct {
	// Authentication token. Requires scope: `remote_files:share`
	Token *string `json:"token,omitempty"`

	// Specify a file registered with Slack by providing its ID. Either this field or `external_id` or both are required.
	File *string `json:"file,omitempty"`

	// The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or `file` or both are required.
	ExternalId *string `json:"external_id,omitempty"`

	// Comma-separated list of channel IDs where the file will be shared.
	Channels *string `json:"channels,omitempty"`
}

// FilesRevokePublicURLJSONBody defines parameters for FilesRevokePublicURL.
type FilesRevokePublicURLJSONBody struct {
	// File to revoke
	File *string `json:"file,omitempty"`
}

// FilesRevokePublicURLParams defines parameters for FilesRevokePublicURL.
type FilesRevokePublicURLParams struct {
	// Authentication token. Requires scope: `files:write:user`
	Token *string `json:"token,omitempty"`
}

// FilesSharedPublicURLJSONBody defines parameters for FilesSharedPublicURL.
type FilesSharedPublicURLJSONBody struct {
	// File to share
	File *string `json:"file,omitempty"`
}

// FilesSharedPublicURLParams defines parameters for FilesSharedPublicURL.
type FilesSharedPublicURLParams struct {
	// Authentication token. Requires scope: `files:write:user`
	Token *string `json:"token,omitempty"`
}

// MigrationExchangeParams defines parameters for MigrationExchange.
type MigrationExchangeParams struct {
	// Authentication token. Requires scope: `tokens.basic`
	Token string `json:"token"`

	// A comma-separated list of user ids, up to 400 per request
	Users string `json:"users"`

	// Specify team_id starts with `T` in case of Org Token
	TeamId *string `json:"team_id,omitempty"`

	// Specify `true` to convert `W` global user IDs to workspace-specific `U` IDs. Defaults to `false`.
	ToOld *bool `json:"to_old,omitempty"`
}

// OauthAccessParams defines parameters for OauthAccess.
type OauthAccessParams struct {
	// Issued when you created your application.
	ClientId *string `json:"client_id,omitempty"`

	// Issued when you created your application.
	ClientSecret *string `json:"client_secret,omitempty"`

	// The `code` param returned via the OAuth callback.
	Code *string `json:"code,omitempty"`

	// This must match the originally submitted URI (if one was sent).
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// Request the user to add your app only to a single channel. Only valid with a [legacy workspace app](https://api.slack.com/legacy-workspace-apps).
	SingleChannel *bool `json:"single_channel,omitempty"`
}

// OauthTokenParams defines parameters for OauthToken.
type OauthTokenParams struct {
	// Issued when you created your application.
	ClientId *string `json:"client_id,omitempty"`

	// Issued when you created your application.
	ClientSecret *string `json:"client_secret,omitempty"`

	// The `code` param returned via the OAuth callback.
	Code *string `json:"code,omitempty"`

	// This must match the originally submitted URI (if one was sent).
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// Request the user to add your app only to a single channel.
	SingleChannel *bool `json:"single_channel,omitempty"`
}

// OauthV2AccessParams defines parameters for OauthV2Access.
type OauthV2AccessParams struct {
	// Issued when you created your application.
	ClientId *string `json:"client_id,omitempty"`

	// Issued when you created your application.
	ClientSecret *string `json:"client_secret,omitempty"`

	// The `code` param returned via the OAuth callback.
	Code string `json:"code"`

	// This must match the originally submitted URI (if one was sent).
	RedirectUri *string `json:"redirect_uri,omitempty"`
}

// PinsAddJSONBody defines parameters for PinsAdd.
type PinsAddJSONBody struct {
	// Channel to pin the item in.
	Channel string `json:"channel"`

	// Timestamp of the message to pin.
	Timestamp *string `json:"timestamp,omitempty"`
}

// PinsAddParams defines parameters for PinsAdd.
type PinsAddParams struct {
	// Authentication token. Requires scope: `pins:write`
	Token string `json:"token"`
}

// PinsListParams defines parameters for PinsList.
type PinsListParams struct {
	// Authentication token. Requires scope: `pins:read`
	Token string `json:"token"`

	// Channel to get pinned items for.
	Channel string `json:"channel"`
}

// PinsRemoveJSONBody defines parameters for PinsRemove.
type PinsRemoveJSONBody struct {
	// Channel where the item is pinned to.
	Channel string `json:"channel"`

	// Timestamp of the message to un-pin.
	Timestamp *string `json:"timestamp,omitempty"`
}

// PinsRemoveParams defines parameters for PinsRemove.
type PinsRemoveParams struct {
	// Authentication token. Requires scope: `pins:write`
	Token string `json:"token"`
}

// ReactionsAddJSONBody defines parameters for ReactionsAdd.
type ReactionsAddJSONBody struct {
	// Channel where the message to add reaction to was posted.
	Channel string `json:"channel"`

	// Reaction (emoji) name.
	Name string `json:"name"`

	// Timestamp of the message to add reaction to.
	Timestamp string `json:"timestamp"`
}

// ReactionsAddParams defines parameters for ReactionsAdd.
type ReactionsAddParams struct {
	// Authentication token. Requires scope: `reactions:write`
	Token string `json:"token"`
}

// ReactionsGetParams defines parameters for ReactionsGet.
type ReactionsGetParams struct {
	// Authentication token. Requires scope: `reactions:read`
	Token string `json:"token"`

	// Channel where the message to get reactions for was posted.
	Channel *string `json:"channel,omitempty"`

	// File to get reactions for.
	File *string `json:"file,omitempty"`

	// File comment to get reactions for.
	FileComment *string `json:"file_comment,omitempty"`

	// If true always return the complete reaction list.
	Full *bool `json:"full,omitempty"`

	// Timestamp of the message to get reactions for.
	Timestamp *string `json:"timestamp,omitempty"`
}

// ReactionsListParams defines parameters for ReactionsList.
type ReactionsListParams struct {
	// Authentication token. Requires scope: `reactions:read`
	Token string `json:"token"`

	// Show reactions made by this user. Defaults to the authed user.
	User *string `json:"user,omitempty"`

	// If true always return the complete reaction list.
	Full  *bool `json:"full,omitempty"`
	Count *int  `json:"count,omitempty"`
	Page  *int  `json:"page,omitempty"`

	// Parameter for pagination. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first "page" of the collection. See [pagination](/docs/pagination) for more details.
	Cursor *string `json:"cursor,omitempty"`

	// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached.
	Limit *int `json:"limit,omitempty"`
}

// ReactionsRemoveJSONBody defines parameters for ReactionsRemove.
type ReactionsRemoveJSONBody struct {
	// Channel where the message to remove reaction from was posted.
	Channel *string `json:"channel,omitempty"`

	// File to remove reaction from.
	File *string `json:"file,omitempty"`

	// File comment to remove reaction from.
	FileComment *string `json:"file_comment,omitempty"`

	// Reaction (emoji) name.
	Name string `json:"name"`

	// Timestamp of the message to remove reaction from.
	Timestamp *string `json:"timestamp,omitempty"`
}

// ReactionsRemoveParams defines parameters for ReactionsRemove.
type ReactionsRemoveParams struct {
	// Authentication token. Requires scope: `reactions:write`
	Token string `json:"token"`
}

// RemindersAddJSONBody defines parameters for RemindersAdd.
type RemindersAddJSONBody struct {
	// The content of the reminder
	Text string `json:"text"`

	// When this reminder should happen: the Unix timestamp (up to five years from now), the number of seconds until the reminder (if within 24 hours), or a natural language description (Ex. "in 15 minutes," or "every Thursday")
	Time string `json:"time"`

	// The user who will receive the reminder. If no user is specified, the reminder will go to user who created it.
	User *string `json:"user,omitempty"`
}

// RemindersAddParams defines parameters for RemindersAdd.
type RemindersAddParams struct {
	// Authentication token. Requires scope: `reminders:write`
	Token string `json:"token"`
}

// RemindersCompleteJSONBody defines parameters for RemindersComplete.
type RemindersCompleteJSONBody struct {
	// The ID of the reminder to be marked as complete
	Reminder *string `json:"reminder,omitempty"`
}

// RemindersCompleteParams defines parameters for RemindersComplete.
type RemindersCompleteParams struct {
	// Authentication token. Requires scope: `reminders:write`
	Token *string `json:"token,omitempty"`
}

// RemindersDeleteJSONBody defines parameters for RemindersDelete.
type RemindersDeleteJSONBody struct {
	// The ID of the reminder
	Reminder *string `json:"reminder,omitempty"`
}

// RemindersDeleteParams defines parameters for RemindersDelete.
type RemindersDeleteParams struct {
	// Authentication token. Requires scope: `reminders:write`
	Token *string `json:"token,omitempty"`
}

// RemindersInfoParams defines parameters for RemindersInfo.
type RemindersInfoParams struct {
	// Authentication token. Requires scope: `reminders:read`
	Token *string `json:"token,omitempty"`

	// The ID of the reminder
	Reminder *string `json:"reminder,omitempty"`
}

// RemindersListParams defines parameters for RemindersList.
type RemindersListParams struct {
	// Authentication token. Requires scope: `reminders:read`
	Token *string `json:"token,omitempty"`
}

// RtmConnectParams defines parameters for RtmConnect.
type RtmConnectParams struct {
	// Authentication token. Requires scope: `rtm:stream`
	Token string `json:"token"`

	// Batch presence deliveries via subscription. Enabling changes the shape of `presence_change` events. See [batch presence](/docs/presence-and-status#batching).
	BatchPresenceAware *bool `json:"batch_presence_aware,omitempty"`

	// Only deliver presence events when requested by subscription. See [presence subscriptions](/docs/presence-and-status#subscriptions).
	PresenceSub *bool `json:"presence_sub,omitempty"`
}

// SearchMessagesParams defines parameters for SearchMessages.
type SearchMessagesParams struct {
	// Authentication token. Requires scope: `search:read`
	Token string `json:"token"`

	// Pass the number of results you want per "page". Maximum of `100`.
	Count *int `json:"count,omitempty"`

	// Pass a value of `true` to enable query highlight markers (see below).
	Highlight *bool `json:"highlight,omitempty"`
	Page      *int  `json:"page,omitempty"`

	// Search query.
	Query string `json:"query"`

	// Return matches sorted by either `score` or `timestamp`.
	Sort *string `json:"sort,omitempty"`

	// Change sort direction to ascending (`asc`) or descending (`desc`).
	SortDir *string `json:"sort_dir,omitempty"`
}

// StarsAddJSONBody defines parameters for StarsAdd.
type StarsAddJSONBody struct {
	// Channel to add star to, or channel where the message to add star to was posted (used with `timestamp`).
	Channel *string `json:"channel,omitempty"`

	// File to add star to.
	File *string `json:"file,omitempty"`

	// File comment to add star to.
	FileComment *string `json:"file_comment,omitempty"`

	// Timestamp of the message to add star to.
	Timestamp *string `json:"timestamp,omitempty"`
}

// StarsAddParams defines parameters for StarsAdd.
type StarsAddParams struct {
	// Authentication token. Requires scope: `stars:write`
	Token string `json:"token"`
}

// StarsListParams defines parameters for StarsList.
type StarsListParams struct {
	// Authentication token. Requires scope: `stars:read`
	Token *string `json:"token,omitempty"`
	Count *string `json:"count,omitempty"`
	Page  *string `json:"page,omitempty"`

	// Parameter for pagination. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first "page" of the collection. See [pagination](/docs/pagination) for more details.
	Cursor *string `json:"cursor,omitempty"`

	// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached.
	Limit *int `json:"limit,omitempty"`
}

// StarsRemoveJSONBody defines parameters for StarsRemove.
type StarsRemoveJSONBody struct {
	// Channel to remove star from, or channel where the message to remove star from was posted (used with `timestamp`).
	Channel *string `json:"channel,omitempty"`

	// File to remove star from.
	File *string `json:"file,omitempty"`

	// File comment to remove star from.
	FileComment *string `json:"file_comment,omitempty"`

	// Timestamp of the message to remove star from.
	Timestamp *string `json:"timestamp,omitempty"`
}

// StarsRemoveParams defines parameters for StarsRemove.
type StarsRemoveParams struct {
	// Authentication token. Requires scope: `stars:write`
	Token string `json:"token"`
}

// TeamAccessLogsParams defines parameters for TeamAccessLogs.
type TeamAccessLogsParams struct {
	// Authentication token. Requires scope: `admin`
	Token string `json:"token"`

	// End of time range of logs to include in results (inclusive).
	Before *string `json:"before,omitempty"`
	Count  *string `json:"count,omitempty"`
	Page   *string `json:"page,omitempty"`
}

// TeamBillableInfoParams defines parameters for TeamBillableInfo.
type TeamBillableInfoParams struct {
	// Authentication token. Requires scope: `admin`
	Token string `json:"token"`

	// A user to retrieve the billable information for. Defaults to all users.
	User *string `json:"user,omitempty"`
}

// TeamInfoParams defines parameters for TeamInfo.
type TeamInfoParams struct {
	// Authentication token. Requires scope: `team:read`
	Token string `json:"token"`

	// Team to get info on, if omitted, will return information about the current team. Will only return team that the authenticated token is allowed to see through external shared channels
	Team *string `json:"team,omitempty"`
}

// TeamIntegrationLogsParams defines parameters for TeamIntegrationLogs.
type TeamIntegrationLogsParams struct {
	// Authentication token. Requires scope: `admin`
	Token string `json:"token"`

	// Filter logs to this Slack app. Defaults to all logs.
	AppId *string `json:"app_id,omitempty"`

	// Filter logs with this change type. Defaults to all logs.
	ChangeType *string `json:"change_type,omitempty"`
	Count      *string `json:"count,omitempty"`
	Page       *string `json:"page,omitempty"`

	// Filter logs to this service. Defaults to all logs.
	ServiceId *string `json:"service_id,omitempty"`

	// Filter logs generated by this users actions. Defaults to all logs.
	User *string `json:"user,omitempty"`
}

// TeamProfileGetParams defines parameters for TeamProfileGet.
type TeamProfileGetParams struct {
	// Authentication token. Requires scope: `users.profile:read`
	Token string `json:"token"`

	// Filter by visibility.
	Visibility *string `json:"visibility,omitempty"`
}

// UsergroupsCreateJSONBody defines parameters for UsergroupsCreate.
type UsergroupsCreateJSONBody struct {
	// A comma separated string of encoded channel IDs for which the User Group uses as a default.
	Channels *string `json:"channels,omitempty"`

	// A short description of the User Group.
	Description *string `json:"description,omitempty"`

	// A mention handle. Must be unique among channels, users and User Groups.
	Handle *string `json:"handle,omitempty"`

	// Include the number of users in each User Group.
	IncludeCount *bool `json:"include_count,omitempty"`

	// A name for the User Group. Must be unique among User Groups.
	Name string `json:"name"`
}

// UsergroupsCreateParams defines parameters for UsergroupsCreate.
type UsergroupsCreateParams struct {
	// Authentication token. Requires scope: `usergroups:write`
	Token string `json:"token"`
}

// UsergroupsDisableJSONBody defines parameters for UsergroupsDisable.
type UsergroupsDisableJSONBody struct {
	// Include the number of users in the User Group.
	IncludeCount *bool `json:"include_count,omitempty"`

	// The encoded ID of the User Group to disable.
	Usergroup string `json:"usergroup"`
}

// UsergroupsDisableParams defines parameters for UsergroupsDisable.
type UsergroupsDisableParams struct {
	// Authentication token. Requires scope: `usergroups:write`
	Token string `json:"token"`
}

// UsergroupsEnableJSONBody defines parameters for UsergroupsEnable.
type UsergroupsEnableJSONBody struct {
	// Include the number of users in the User Group.
	IncludeCount *bool `json:"include_count,omitempty"`

	// The encoded ID of the User Group to enable.
	Usergroup string `json:"usergroup"`
}

// UsergroupsEnableParams defines parameters for UsergroupsEnable.
type UsergroupsEnableParams struct {
	// Authentication token. Requires scope: `usergroups:write`
	Token string `json:"token"`
}

// UsergroupsListParams defines parameters for UsergroupsList.
type UsergroupsListParams struct {
	// Include the list of users for each User Group.
	IncludeUsers *bool `json:"include_users,omitempty"`

	// Authentication token. Requires scope: `usergroups:read`
	Token string `json:"token"`

	// Include the number of users in each User Group.
	IncludeCount *bool `json:"include_count,omitempty"`

	// Include disabled User Groups.
	IncludeDisabled *bool `json:"include_disabled,omitempty"`
}

// UsergroupsUpdateJSONBody defines parameters for UsergroupsUpdate.
type UsergroupsUpdateJSONBody struct {
	// A comma separated string of encoded channel IDs for which the User Group uses as a default.
	Channels *string `json:"channels,omitempty"`

	// A short description of the User Group.
	Description *string `json:"description,omitempty"`

	// A mention handle. Must be unique among channels, users and User Groups.
	Handle *string `json:"handle,omitempty"`

	// Include the number of users in the User Group.
	IncludeCount *bool `json:"include_count,omitempty"`

	// A name for the User Group. Must be unique among User Groups.
	Name *string `json:"name,omitempty"`

	// The encoded ID of the User Group to update.
	Usergroup string `json:"usergroup"`
}

// UsergroupsUpdateParams defines parameters for UsergroupsUpdate.
type UsergroupsUpdateParams struct {
	// Authentication token. Requires scope: `usergroups:write`
	Token string `json:"token"`
}

// UsergroupsUsersListParams defines parameters for UsergroupsUsersList.
type UsergroupsUsersListParams struct {
	// Authentication token. Requires scope: `usergroups:read`
	Token string `json:"token"`

	// Allow results that involve disabled User Groups.
	IncludeDisabled *bool `json:"include_disabled,omitempty"`

	// The encoded ID of the User Group to update.
	Usergroup string `json:"usergroup"`
}

// UsergroupsUsersUpdateJSONBody defines parameters for UsergroupsUsersUpdate.
type UsergroupsUsersUpdateJSONBody struct {
	// Include the number of users in the User Group.
	IncludeCount *bool `json:"include_count,omitempty"`

	// The encoded ID of the User Group to update.
	Usergroup string `json:"usergroup"`

	// A comma separated string of encoded user IDs that represent the entire list of users for the User Group.
	Users string `json:"users"`
}

// UsergroupsUsersUpdateParams defines parameters for UsergroupsUsersUpdate.
type UsergroupsUsersUpdateParams struct {
	// Authentication token. Requires scope: `usergroups:write`
	Token string `json:"token"`
}

// UsersConversationsParams defines parameters for UsersConversations.
type UsersConversationsParams struct {
	// Authentication token. Requires scope: `conversations:read`
	Token *string `json:"token,omitempty"`

	// Browse conversations by a specific user ID's membership. Non-public channels are restricted to those where the calling user shares membership.
	User *string `json:"user,omitempty"`

	// Mix and match channel types by providing a comma-separated list of any combination of `public_channel`, `private_channel`, `mpim`, `im`
	Types *string `json:"types,omitempty"`

	// Set to `true` to exclude archived channels from the list
	ExcludeArchived *bool `json:"exclude_archived,omitempty"`

	// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. Must be an integer no larger than 1000.
	Limit *int `json:"limit,omitempty"`

	// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail.
	Cursor *string `json:"cursor,omitempty"`
}

// UsersGetPresenceParams defines parameters for UsersGetPresence.
type UsersGetPresenceParams struct {
	// Authentication token. Requires scope: `users:read`
	Token string `json:"token"`

	// User to get presence info on. Defaults to the authed user.
	User *string `json:"user,omitempty"`
}

// UsersIdentityParams defines parameters for UsersIdentity.
type UsersIdentityParams struct {
	// Authentication token. Requires scope: `identity.basic`
	Token *string `json:"token,omitempty"`
}

// UsersInfoParams defines parameters for UsersInfo.
type UsersInfoParams struct {
	// Authentication token. Requires scope: `users:read`
	Token string `json:"token"`

	// Set this to `true` to receive the locale for this user. Defaults to `false`
	IncludeLocale *bool `json:"include_locale,omitempty"`

	// User to get info on
	User *string `json:"user,omitempty"`
}

// UsersListParams defines parameters for UsersList.
type UsersListParams struct {
	// Authentication token. Requires scope: `users:read`
	Token *string `json:"token,omitempty"`

	// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached. Providing no `limit` value will result in Slack attempting to deliver you the entire result set. If the collection is too large you may experience `limit_required` or HTTP 500 errors.
	Limit *int `json:"limit,omitempty"`

	// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail.
	Cursor *string `json:"cursor,omitempty"`

	// Set this to `true` to receive the locale for users. Defaults to `false`
	IncludeLocale *bool `json:"include_locale,omitempty"`
}

// UsersLookupByEmailParams defines parameters for UsersLookupByEmail.
type UsersLookupByEmailParams struct {
	// Authentication token. Requires scope: `users:read.email`
	Token string `json:"token"`

	// An email address belonging to a user in the workspace
	Email string `json:"email"`
}

// UsersProfileGetParams defines parameters for UsersProfileGet.
type UsersProfileGetParams struct {
	// Authentication token. Requires scope: `users.profile:read`
	Token string `json:"token"`

	// Include labels for each ID in custom profile fields
	IncludeLabels *bool `json:"include_labels,omitempty"`

	// User to retrieve profile info for
	User *string `json:"user,omitempty"`
}

// UsersProfileSetJSONBody defines parameters for UsersProfileSet.
type UsersProfileSetJSONBody struct {
	// Name of a single key to set. Usable only if `profile` is not passed.
	Name *string `json:"name,omitempty"`

	// Collection of key:value pairs presented as a URL-encoded JSON hash. At most 50 fields may be set. Each field name is limited to 255 characters.
	Profile *string `json:"profile,omitempty"`

	// ID of user to change. This argument may only be specified by team admins on paid teams.
	User *string `json:"user,omitempty"`

	// Value to set a single key to. Usable only if `profile` is not passed.
	Value *string `json:"value,omitempty"`
}

// UsersProfileSetParams defines parameters for UsersProfileSet.
type UsersProfileSetParams struct {
	// Authentication token. Requires scope: `users.profile:write`
	Token string `json:"token"`
}

// UsersSetActiveParams defines parameters for UsersSetActive.
type UsersSetActiveParams struct {
	// Authentication token. Requires scope: `users:write`
	Token string `json:"token"`
}

// UsersSetPresenceJSONBody defines parameters for UsersSetPresence.
type UsersSetPresenceJSONBody struct {
	// Either `auto` or `away`
	Presence string `json:"presence"`
}

// UsersSetPresenceParams defines parameters for UsersSetPresence.
type UsersSetPresenceParams struct {
	// Authentication token. Requires scope: `users:write`
	Token string `json:"token"`
}

// ViewsOpenParams defines parameters for ViewsOpen.
type ViewsOpenParams struct {
	// Exchange a trigger to post to the user.
	TriggerId string `json:"trigger_id"`

	// A [view payload](/reference/surfaces/views). This must be a JSON-encoded string.
	View string `json:"view"`

	// Authentication token. Requires scope: `none`
	Token string `json:"token"`
}

// ViewsPublishParams defines parameters for ViewsPublish.
type ViewsPublishParams struct {
	// `id` of the user you want publish a view to.
	UserId string `json:"user_id"`

	// A [view payload](/reference/surfaces/views). This must be a JSON-encoded string.
	View string `json:"view"`

	// A string that represents view state to protect against possible race conditions.
	Hash *string `json:"hash,omitempty"`

	// Authentication token. Requires scope: `none`
	Token string `json:"token"`
}

// ViewsPushParams defines parameters for ViewsPush.
type ViewsPushParams struct {
	// Exchange a trigger to post to the user.
	TriggerId string `json:"trigger_id"`

	// A [view payload](/reference/surfaces/views). This must be a JSON-encoded string.
	View string `json:"view"`

	// Authentication token. Requires scope: `none`
	Token string `json:"token"`
}

// ViewsUpdateParams defines parameters for ViewsUpdate.
type ViewsUpdateParams struct {
	// A unique identifier of the view to be updated. Either `view_id` or `external_id` is required.
	ViewId *string `json:"view_id,omitempty"`

	// A unique identifier of the view set by the developer. Must be unique for all views on a team. Max length of 255 characters. Either `view_id` or `external_id` is required.
	ExternalId *string `json:"external_id,omitempty"`

	// A [view object](/reference/surfaces/views). This must be a JSON-encoded string.
	View *string `json:"view,omitempty"`

	// A string that represents view state to protect against possible race conditions.
	Hash *string `json:"hash,omitempty"`

	// Authentication token. Requires scope: `none`
	Token string `json:"token"`
}

// WorkflowsStepCompletedParams defines parameters for WorkflowsStepCompleted.
type WorkflowsStepCompletedParams struct {
	// Context identifier that maps to the correct workflow step execution.
	WorkflowStepExecuteId string `json:"workflow_step_execute_id"`

	// Key-value object of outputs from your step. Keys of this object reflect the configured `key` properties of your [`outputs`](/reference/workflows/workflow_step#output) array from your `workflow_step` object.
	Outputs *string `json:"outputs,omitempty"`

	// Authentication token. Requires scope: `workflow.steps:execute`
	Token string `json:"token"`
}

// WorkflowsStepFailedParams defines parameters for WorkflowsStepFailed.
type WorkflowsStepFailedParams struct {
	// Context identifier that maps to the correct workflow step execution.
	WorkflowStepExecuteId string `json:"workflow_step_execute_id"`

	// A JSON-based object with a `message` property that should contain a human readable error message.
	Error string `json:"error"`

	// Authentication token. Requires scope: `workflow.steps:execute`
	Token string `json:"token"`
}

// WorkflowsUpdateStepParams defines parameters for WorkflowsUpdateStep.
type WorkflowsUpdateStepParams struct {
	// A context identifier provided with `view_submission` payloads used to call back to `workflows.updateStep`.
	WorkflowStepEditId string `json:"workflow_step_edit_id"`

	// A JSON key-value map of inputs required from a user during configuration. This is the data your app expects to receive when the workflow step starts. **Please note**: the embedded variable format is set and replaced by the workflow system. You cannot create custom variables that will be replaced at runtime. [Read more about variables in workflow steps here](/workflows/steps#variables).
	Inputs *string `json:"inputs,omitempty"`

	// An JSON array of output objects used during step execution. This is the data your app agrees to provide when your workflow step was executed.
	Outputs *string `json:"outputs,omitempty"`

	// An optional field that can be used to override the step name that is shown in the Workflow Builder.
	StepName *string `json:"step_name,omitempty"`

	// An optional field that can be used to override app image that is shown in the Workflow Builder.
	StepImageUrl *string `json:"step_image_url,omitempty"`

	// Authentication token. Requires scope: `workflow.steps:execute`
	Token string `json:"token"`
}

// AdminAppsApproveJSONRequestBody defines body for AdminAppsApprove for application/json ContentType.
type AdminAppsApproveJSONRequestBody AdminAppsApproveJSONBody

// AdminAppsRestrictJSONRequestBody defines body for AdminAppsRestrict for application/json ContentType.
type AdminAppsRestrictJSONRequestBody AdminAppsRestrictJSONBody

// AdminConversationsArchiveJSONRequestBody defines body for AdminConversationsArchive for application/json ContentType.
type AdminConversationsArchiveJSONRequestBody AdminConversationsArchiveJSONBody

// AdminConversationsConvertToPrivateJSONRequestBody defines body for AdminConversationsConvertToPrivate for application/json ContentType.
type AdminConversationsConvertToPrivateJSONRequestBody AdminConversationsConvertToPrivateJSONBody

// AdminConversationsCreateJSONRequestBody defines body for AdminConversationsCreate for application/json ContentType.
type AdminConversationsCreateJSONRequestBody AdminConversationsCreateJSONBody

// AdminConversationsDeleteJSONRequestBody defines body for AdminConversationsDelete for application/json ContentType.
type AdminConversationsDeleteJSONRequestBody AdminConversationsDeleteJSONBody

// AdminConversationsDisconnectSharedJSONRequestBody defines body for AdminConversationsDisconnectShared for application/json ContentType.
type AdminConversationsDisconnectSharedJSONRequestBody AdminConversationsDisconnectSharedJSONBody

// AdminConversationsInviteJSONRequestBody defines body for AdminConversationsInvite for application/json ContentType.
type AdminConversationsInviteJSONRequestBody AdminConversationsInviteJSONBody

// AdminConversationsRenameJSONRequestBody defines body for AdminConversationsRename for application/json ContentType.
type AdminConversationsRenameJSONRequestBody AdminConversationsRenameJSONBody

// AdminConversationsSetConversationPrefsJSONRequestBody defines body for AdminConversationsSetConversationPrefs for application/json ContentType.
type AdminConversationsSetConversationPrefsJSONRequestBody AdminConversationsSetConversationPrefsJSONBody

// AdminConversationsSetTeamsJSONRequestBody defines body for AdminConversationsSetTeams for application/json ContentType.
type AdminConversationsSetTeamsJSONRequestBody AdminConversationsSetTeamsJSONBody

// AdminConversationsUnarchiveJSONRequestBody defines body for AdminConversationsUnarchive for application/json ContentType.
type AdminConversationsUnarchiveJSONRequestBody AdminConversationsUnarchiveJSONBody

// AdminInviteRequestsApproveJSONRequestBody defines body for AdminInviteRequestsApprove for application/json ContentType.
type AdminInviteRequestsApproveJSONRequestBody AdminInviteRequestsApproveJSONBody

// AdminInviteRequestsDenyJSONRequestBody defines body for AdminInviteRequestsDeny for application/json ContentType.
type AdminInviteRequestsDenyJSONRequestBody AdminInviteRequestsDenyJSONBody

// AdminTeamsCreateJSONRequestBody defines body for AdminTeamsCreate for application/json ContentType.
type AdminTeamsCreateJSONRequestBody AdminTeamsCreateJSONBody

// AdminTeamsSettingsSetDescriptionJSONRequestBody defines body for AdminTeamsSettingsSetDescription for application/json ContentType.
type AdminTeamsSettingsSetDescriptionJSONRequestBody AdminTeamsSettingsSetDescriptionJSONBody

// AdminTeamsSettingsSetDiscoverabilityJSONRequestBody defines body for AdminTeamsSettingsSetDiscoverability for application/json ContentType.
type AdminTeamsSettingsSetDiscoverabilityJSONRequestBody AdminTeamsSettingsSetDiscoverabilityJSONBody

// AdminTeamsSettingsSetNameJSONRequestBody defines body for AdminTeamsSettingsSetName for application/json ContentType.
type AdminTeamsSettingsSetNameJSONRequestBody AdminTeamsSettingsSetNameJSONBody

// AdminUsergroupsAddChannelsJSONRequestBody defines body for AdminUsergroupsAddChannels for application/json ContentType.
type AdminUsergroupsAddChannelsJSONRequestBody AdminUsergroupsAddChannelsJSONBody

// AdminUsergroupsAddTeamsJSONRequestBody defines body for AdminUsergroupsAddTeams for application/json ContentType.
type AdminUsergroupsAddTeamsJSONRequestBody AdminUsergroupsAddTeamsJSONBody

// AdminUsergroupsRemoveChannelsJSONRequestBody defines body for AdminUsergroupsRemoveChannels for application/json ContentType.
type AdminUsergroupsRemoveChannelsJSONRequestBody AdminUsergroupsRemoveChannelsJSONBody

// AdminUsersAssignJSONRequestBody defines body for AdminUsersAssign for application/json ContentType.
type AdminUsersAssignJSONRequestBody AdminUsersAssignJSONBody

// AdminUsersInviteJSONRequestBody defines body for AdminUsersInvite for application/json ContentType.
type AdminUsersInviteJSONRequestBody AdminUsersInviteJSONBody

// AdminUsersRemoveJSONRequestBody defines body for AdminUsersRemove for application/json ContentType.
type AdminUsersRemoveJSONRequestBody AdminUsersRemoveJSONBody

// AdminUsersSessionInvalidateJSONRequestBody defines body for AdminUsersSessionInvalidate for application/json ContentType.
type AdminUsersSessionInvalidateJSONRequestBody AdminUsersSessionInvalidateJSONBody

// AdminUsersSessionResetJSONRequestBody defines body for AdminUsersSessionReset for application/json ContentType.
type AdminUsersSessionResetJSONRequestBody AdminUsersSessionResetJSONBody

// AdminUsersSetAdminJSONRequestBody defines body for AdminUsersSetAdmin for application/json ContentType.
type AdminUsersSetAdminJSONRequestBody AdminUsersSetAdminJSONBody

// AdminUsersSetExpirationJSONRequestBody defines body for AdminUsersSetExpiration for application/json ContentType.
type AdminUsersSetExpirationJSONRequestBody AdminUsersSetExpirationJSONBody

// AdminUsersSetOwnerJSONRequestBody defines body for AdminUsersSetOwner for application/json ContentType.
type AdminUsersSetOwnerJSONRequestBody AdminUsersSetOwnerJSONBody

// AdminUsersSetRegularJSONRequestBody defines body for AdminUsersSetRegular for application/json ContentType.
type AdminUsersSetRegularJSONRequestBody AdminUsersSetRegularJSONBody

// CallsAddJSONRequestBody defines body for CallsAdd for application/json ContentType.
type CallsAddJSONRequestBody CallsAddJSONBody

// CallsEndJSONRequestBody defines body for CallsEnd for application/json ContentType.
type CallsEndJSONRequestBody CallsEndJSONBody

// CallsParticipantsAddJSONRequestBody defines body for CallsParticipantsAdd for application/json ContentType.
type CallsParticipantsAddJSONRequestBody CallsParticipantsAddJSONBody

// CallsParticipantsRemoveJSONRequestBody defines body for CallsParticipantsRemove for application/json ContentType.
type CallsParticipantsRemoveJSONRequestBody CallsParticipantsRemoveJSONBody

// CallsUpdateJSONRequestBody defines body for CallsUpdate for application/json ContentType.
type CallsUpdateJSONRequestBody CallsUpdateJSONBody

// ChatDeleteJSONRequestBody defines body for ChatDelete for application/json ContentType.
type ChatDeleteJSONRequestBody ChatDeleteJSONBody

// ChatDeleteScheduledMessageJSONRequestBody defines body for ChatDeleteScheduledMessage for application/json ContentType.
type ChatDeleteScheduledMessageJSONRequestBody ChatDeleteScheduledMessageJSONBody

// ChatMeMessageJSONRequestBody defines body for ChatMeMessage for application/json ContentType.
type ChatMeMessageJSONRequestBody ChatMeMessageJSONBody

// ChatPostEphemeralJSONRequestBody defines body for ChatPostEphemeral for application/json ContentType.
type ChatPostEphemeralJSONRequestBody ChatPostEphemeralJSONBody

// ChatPostMessageJSONRequestBody defines body for ChatPostMessage for application/json ContentType.
type ChatPostMessageJSONRequestBody ChatPostMessageJSONBody

// ChatScheduleMessageJSONRequestBody defines body for ChatScheduleMessage for application/json ContentType.
type ChatScheduleMessageJSONRequestBody ChatScheduleMessageJSONBody

// ChatUnfurlJSONRequestBody defines body for ChatUnfurl for application/json ContentType.
type ChatUnfurlJSONRequestBody ChatUnfurlJSONBody

// ChatUpdateJSONRequestBody defines body for ChatUpdate for application/json ContentType.
type ChatUpdateJSONRequestBody ChatUpdateJSONBody

// ConversationsArchiveJSONRequestBody defines body for ConversationsArchive for application/json ContentType.
type ConversationsArchiveJSONRequestBody ConversationsArchiveJSONBody

// ConversationsCloseJSONRequestBody defines body for ConversationsClose for application/json ContentType.
type ConversationsCloseJSONRequestBody ConversationsCloseJSONBody

// ConversationsCreateJSONRequestBody defines body for ConversationsCreate for application/json ContentType.
type ConversationsCreateJSONRequestBody ConversationsCreateJSONBody

// ConversationsInviteJSONRequestBody defines body for ConversationsInvite for application/json ContentType.
type ConversationsInviteJSONRequestBody ConversationsInviteJSONBody

// ConversationsJoinJSONRequestBody defines body for ConversationsJoin for application/json ContentType.
type ConversationsJoinJSONRequestBody ConversationsJoinJSONBody

// ConversationsKickJSONRequestBody defines body for ConversationsKick for application/json ContentType.
type ConversationsKickJSONRequestBody ConversationsKickJSONBody

// ConversationsLeaveJSONRequestBody defines body for ConversationsLeave for application/json ContentType.
type ConversationsLeaveJSONRequestBody ConversationsLeaveJSONBody

// ConversationsMarkJSONRequestBody defines body for ConversationsMark for application/json ContentType.
type ConversationsMarkJSONRequestBody ConversationsMarkJSONBody

// ConversationsOpenJSONRequestBody defines body for ConversationsOpen for application/json ContentType.
type ConversationsOpenJSONRequestBody ConversationsOpenJSONBody

// ConversationsRenameJSONRequestBody defines body for ConversationsRename for application/json ContentType.
type ConversationsRenameJSONRequestBody ConversationsRenameJSONBody

// ConversationsSetPurposeJSONRequestBody defines body for ConversationsSetPurpose for application/json ContentType.
type ConversationsSetPurposeJSONRequestBody ConversationsSetPurposeJSONBody

// ConversationsSetTopicJSONRequestBody defines body for ConversationsSetTopic for application/json ContentType.
type ConversationsSetTopicJSONRequestBody ConversationsSetTopicJSONBody

// ConversationsUnarchiveJSONRequestBody defines body for ConversationsUnarchive for application/json ContentType.
type ConversationsUnarchiveJSONRequestBody ConversationsUnarchiveJSONBody

// FilesCommentsDeleteJSONRequestBody defines body for FilesCommentsDelete for application/json ContentType.
type FilesCommentsDeleteJSONRequestBody FilesCommentsDeleteJSONBody

// FilesDeleteJSONRequestBody defines body for FilesDelete for application/json ContentType.
type FilesDeleteJSONRequestBody FilesDeleteJSONBody

// FilesRevokePublicURLJSONRequestBody defines body for FilesRevokePublicURL for application/json ContentType.
type FilesRevokePublicURLJSONRequestBody FilesRevokePublicURLJSONBody

// FilesSharedPublicURLJSONRequestBody defines body for FilesSharedPublicURL for application/json ContentType.
type FilesSharedPublicURLJSONRequestBody FilesSharedPublicURLJSONBody

// PinsAddJSONRequestBody defines body for PinsAdd for application/json ContentType.
type PinsAddJSONRequestBody PinsAddJSONBody

// PinsRemoveJSONRequestBody defines body for PinsRemove for application/json ContentType.
type PinsRemoveJSONRequestBody PinsRemoveJSONBody

// ReactionsAddJSONRequestBody defines body for ReactionsAdd for application/json ContentType.
type ReactionsAddJSONRequestBody ReactionsAddJSONBody

// ReactionsRemoveJSONRequestBody defines body for ReactionsRemove for application/json ContentType.
type ReactionsRemoveJSONRequestBody ReactionsRemoveJSONBody

// RemindersAddJSONRequestBody defines body for RemindersAdd for application/json ContentType.
type RemindersAddJSONRequestBody RemindersAddJSONBody

// RemindersCompleteJSONRequestBody defines body for RemindersComplete for application/json ContentType.
type RemindersCompleteJSONRequestBody RemindersCompleteJSONBody

// RemindersDeleteJSONRequestBody defines body for RemindersDelete for application/json ContentType.
type RemindersDeleteJSONRequestBody RemindersDeleteJSONBody

// StarsAddJSONRequestBody defines body for StarsAdd for application/json ContentType.
type StarsAddJSONRequestBody StarsAddJSONBody

// StarsRemoveJSONRequestBody defines body for StarsRemove for application/json ContentType.
type StarsRemoveJSONRequestBody StarsRemoveJSONBody

// UsergroupsCreateJSONRequestBody defines body for UsergroupsCreate for application/json ContentType.
type UsergroupsCreateJSONRequestBody UsergroupsCreateJSONBody

// UsergroupsDisableJSONRequestBody defines body for UsergroupsDisable for application/json ContentType.
type UsergroupsDisableJSONRequestBody UsergroupsDisableJSONBody

// UsergroupsEnableJSONRequestBody defines body for UsergroupsEnable for application/json ContentType.
type UsergroupsEnableJSONRequestBody UsergroupsEnableJSONBody

// UsergroupsUpdateJSONRequestBody defines body for UsergroupsUpdate for application/json ContentType.
type UsergroupsUpdateJSONRequestBody UsergroupsUpdateJSONBody

// UsergroupsUsersUpdateJSONRequestBody defines body for UsergroupsUsersUpdate for application/json ContentType.
type UsergroupsUsersUpdateJSONRequestBody UsergroupsUsersUpdateJSONBody

// UsersProfileSetJSONRequestBody defines body for UsersProfileSet for application/json ContentType.
type UsersProfileSetJSONRequestBody UsersProfileSetJSONBody

// UsersSetPresenceJSONRequestBody defines body for UsersSetPresence for application/json ContentType.
type UsersSetPresenceJSONRequestBody UsersSetPresenceJSONBody

// Getter for additional properties for ConversationsListErrorResponseBody. Returns the specified
// element and whether it was found
func (a ConversationsListErrorResponseBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConversationsListErrorResponseBody
func (a *ConversationsListErrorResponseBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConversationsListErrorResponseBody to handle AdditionalProperties
func (a *ConversationsListErrorResponseBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["ok"]; found {
		err = json.Unmarshal(raw, &a.Ok)
		if err != nil {
			return fmt.Errorf("error reading 'ok': %w", err)
		}
		delete(object, "ok")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConversationsListErrorResponseBody to handle AdditionalProperties
func (a ConversationsListErrorResponseBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["error"], err = json.Marshal(a.Error)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'error': %w", err)
	}

	object["ok"], err = json.Marshal(a.Ok)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'ok': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ConversationsListResponseBody. Returns the specified
// element and whether it was found
func (a ConversationsListResponseBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConversationsListResponseBody
func (a *ConversationsListResponseBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConversationsListResponseBody to handle AdditionalProperties
func (a *ConversationsListResponseBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["channels"]; found {
		err = json.Unmarshal(raw, &a.Channels)
		if err != nil {
			return fmt.Errorf("error reading 'channels': %w", err)
		}
		delete(object, "channels")
	}

	if raw, found := object["ok"]; found {
		err = json.Unmarshal(raw, &a.Ok)
		if err != nil {
			return fmt.Errorf("error reading 'ok': %w", err)
		}
		delete(object, "ok")
	}

	if raw, found := object["response_metadata"]; found {
		err = json.Unmarshal(raw, &a.ResponseMetadata)
		if err != nil {
			return fmt.Errorf("error reading 'response_metadata': %w", err)
		}
		delete(object, "response_metadata")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConversationsListResponseBody to handle AdditionalProperties
func (a ConversationsListResponseBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["channels"], err = json.Marshal(a.Channels)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'channels': %w", err)
	}

	object["ok"], err = json.Marshal(a.Ok)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'ok': %w", err)
	}

	object["response_metadata"], err = json.Marshal(a.ResponseMetadata)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'response_metadata': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
